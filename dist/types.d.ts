/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * atomic radius
 */
export type AtomicRadius = AtomicRadius1 & AtomicRadius2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:elemental:atomic-radius".
 */
export type AtomicRadius1 = ScalarSchema;
/**
 * electronegativity for the element (Pauling scale)
 */
export type Electronegativity = Electronegativity1 & Electronegativity2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:elemental:electronegativity".
 */
export type Electronegativity1 = ScalarSchema;
/**
 * ionization potential for the element
 */
export type IonizationPotential = IonizationPotential1 & IonizationPotential2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:elemental:ionization-potential".
 */
export type IonizationPotential1 = ScalarSchema;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "job".
 */
export type JobSchema = JobSchema1 & JobSchema2;
export type JobSchema1 = BaseJobSchema;
export type BaseJobSchema = BaseJobSchema1 & BaseJobSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "job:base".
 */
export type BaseJobSchema1 = NamedDefaultableHasMetadataInMemoryEntitySchema;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "in-memory-entity:named-defaultable-has-metadata".
 */
export type NamedDefaultableHasMetadataInMemoryEntitySchema = BaseInMemoryEntitySchema & NameEntitySchema & DefaultableEntitySchema & MetadataSchema;
export type BaseInMemoryEntitySchema = BaseInMemoryEntitySchema1 & BaseInMemoryEntitySchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "in-memory-entity:base".
 */
export type BaseInMemoryEntitySchema1 = SchemaVersion;
export type WorkflowSchema = WorkflowSchema1 & WorkflowSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow".
 */
export type WorkflowSchema1 = BaseWorkflowSchema;
export type BaseWorkflowSchema = BaseWorkflowSchema1 & BaseWorkflowSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:base".
 */
export type BaseWorkflowSchema1 = NamedDefaultableHasMetadataInMemoryEntitySchema;
export type Subworkflow = Subworkflow1 & Subworkflow2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:subworkflow".
 */
export type Subworkflow1 = BaseFlow;
export type WorkflowUnitSchema = WorkflowUnitSchema1 & WorkflowUnitSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit".
 */
export type WorkflowUnitSchema1 = NamedDefaultableRuntimeItemsInMemoryEntitySchema & EntityTagsSchema;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "in-memory-entity:named-defaultable-runtime-items".
 */
export type NamedDefaultableRuntimeItemsInMemoryEntitySchema = BaseInMemoryEntitySchema1 & NameEntitySchema & DefaultableEntitySchema & RuntimeItemsSchemaPrePostProcessorsMonitorsResults;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit:runtime:runtime-item".
 */
export type RuntimeItemSchema = NameResultSchema | RuntimeItemString;
/**
 * name of runtime item in shortened notation
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit:runtime:-runtime-item-string".
 */
export type RuntimeItemString = string;
export type DataIOUnitSchema = DataIOUnitSchema1 & DataIOUnitSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit:io".
 */
export type DataIOUnitSchema1 = WorkflowUnitSchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit:io:db".
 */
export type DataIODatabaseInputOutputSchema = {
    /**
     * IDs of item to retrieve from db
     */
    ids: string[];
} | {
    /**
     * db collection name
     */
    collection: string;
    /**
     * whether the result should be saved as draft
     */
    draft: boolean;
};
export type MapUnitSchema = MapUnitSchema1 & MapUnitSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit:map".
 */
export type MapUnitSchema1 = WorkflowUnitSchema1;
export type ReduceUnitSchema = ReduceUnitSchema1 & ReduceUnitSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit:reduce".
 */
export type ReduceUnitSchema1 = WorkflowUnitSchema1;
export type ConditionUnitSchema = ConditionUnitSchema1 & ConditionUnitSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit:condition".
 */
export type ConditionUnitSchema1 = WorkflowUnitSchema1;
export type AssertionUnitSchema = AssertionUnitSchema1 & AssertionUnitSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit:assertion".
 */
export type AssertionUnitSchema1 = WorkflowUnitSchema1;
export type ExecutionUnitSchemaBase = ExecutionUnitSchemaBase1 & ExecutionUnitSchemaBase2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit:execution".
 */
export type ExecutionUnitSchemaBase1 = WorkflowUnitSchema1 & RuntimeItemsSchemaPrePostProcessorsMonitorsResults;
export type ExecutableSchema = ExecutableSchema1 & ExecutableSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software:executable".
 */
export type ExecutableSchema1 = RuntimeItemsSchemaPrePostProcessorsMonitorsResults;
export type FlavorSchema = FlavorSchema1 & FlavorSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software:flavor".
 */
export type FlavorSchema1 = RuntimeItemsSchemaPrePostProcessorsMonitorsResults;
export type ExecutionUnitInputSchema = ExecutionUnitInputIdItemSchemaForPhysicsBasedSimulationEngines[];
export type AssignmentUnitSchema = AssignmentUnitSchema1 & AssignmentUnitSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit:assignment".
 */
export type AssignmentUnitSchema1 = WorkflowUnitSchema1;
export type ProcessingUnitSchema = ProcessingUnitSchema1 & ProcessingUnitSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit:processing".
 */
export type ProcessingUnitSchema1 = WorkflowUnitSchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "material".
 */
export type MaterialSchema = MaterialSchema1 & MaterialSchema2;
export type MaterialSchema1 = NamedDefaultableHasMetadataInMemoryEntitySchema;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:abstract:vector".
 */
export type VectorSchema = ArrayOf3NumberElementsSchema | ArrayOf3BooleanElementsSchema;
/**
 * @minItems 3
 * @maxItems 3
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:primitive:array-of-:-numbers".
 */
export type ArrayOf3NumberElementsSchema = [number, number, number];
/**
 * @minItems 3
 * @maxItems 3
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:primitive:array-of-:-booleans".
 */
export type ArrayOf3BooleanElementsSchema = [boolean, boolean, boolean];
/**
 * array of objects containing integer id each
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:primitive:array-of-ids".
 */
export type AtomicIds = {
    /**
     * integer id of this entry
     */
    id?: number;
}[];
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:basis:bonds".
 */
export type BondsSchema = {
    /**
     * indices of the two connected atoms
     */
    atomPair?: AtomicIds;
    bondType?: "single" | "double" | "triple" | "quadruple" | "aromatic" | "tautomeric" | "dative" | "other";
}[];
export type LatticeSchema = LatticeSchema1 & LatticeSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:lattice".
 */
export type LatticeSchema1 = {
    vectors?: LatticeExplicitUnit;
} & LatticeImplicitSchema;
export type LatticeExplicitUnit = LatticeExplicitUnit1 & LatticeExplicitUnit2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:lattice:lattice-vectors".
 */
export type LatticeExplicitUnit1 = DimensionalVectorBasis;
export type LatticeImplicitSchema = LatticeImplicitSchema1 & LatticeImplicitSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:lattice:lattice-bravais".
 */
export type LatticeImplicitSchema1 = DimensionalLatticeSchema;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:lattice:type-enum".
 */
export type LatticeTypeSchema = "CUB" | "BCC" | "FCC" | "TET" | "MCL" | "ORC" | "ORCC" | "ORCF" | "ORCI" | "HEX" | "BCT" | "TRI" | "MCLC" | "RHL";
export type VolumeSchema = VolumeSchema1 & VolumeSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:volume".
 */
export type VolumeSchema1 = ScalarSchema;
export type DensitySchema = DensitySchema1 & DensitySchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:density".
 */
export type DensitySchema1 = ScalarSchema;
/**
 * ration of this element in the compound
 */
export type ElementalRatio = ElementalRatio1 & ElementalRatio2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:elemental-ratio".
 */
export type ElementalRatio1 = ScalarSchema;
/**
 * https://en.wikipedia.org/wiki/Norm_(mathematics)#p-norm
 */
export type PNorm = PNorm1 & PNorm2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:p-norm".
 */
export type PNorm1 = ScalarSchema;
export type InChIRepresentationSchema = InChIRepresentationSchema1 & InChIRepresentationSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:inchi".
 */
export type InChIRepresentationSchema1 = PrimitiveString;
export type InChIKeyRepresentationSchema = InChIKeyRepresentationSchema1 & InChIKeyRepresentationSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:inchi-key".
 */
export type InChIKeyRepresentationSchema1 = PrimitiveString;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:derived-properties".
 */
export type DerivedPropertiesSchema = (VolumeSchema | DensitySchema | SymmetrySchema | ElementalRatio | PNorm | InChIRepresentationSchema | InChIKeyRepresentationSchema)[];
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "project".
 */
export type ProjectSchema = ProjectSchema1 & ProjectSchema2;
export type ProjectSchema1 = NamedDefaultableHasMetadataInMemoryEntitySchema;
export type SystemSchema = SystemSchema1 & SystemSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` ":pse:file:applications:espresso:::::pw:x:system".
 */
export type SystemSchema1 = {
    celldm?: number[];
} | {
    A?: number;
    B?: number;
    C?: number;
    cosAB?: number;
    cosAC?: number;
    cosBC?: number;
};
export type IonsSchema = IonsSchema1 & IonsSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` ":pse:file:applications:espresso:::::pw:x:ions".
 */
export type IonsSchema2 = {
    /**
     * CASE: calculation == 'relax'
     */
    ion_dynamics?: "bfgs" | "damp" | "fire";
} | {
    /**
     * CASE: calculation == 'md'
     */
    ion_dynamics?: "verlet" | "langevin" | "langevin-smc";
} | {
    /**
     * CASE: calculation == 'vc-relax'
     */
    ion_dynamics?: "bfgs" | "damp";
} | {
    /**
     * CASE: calculation == 'vc-md'
     */
    ion_dynamics?: "beeman";
};
export type CellSchema = CellSchema1 & CellSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` ":pse:file:applications:espresso:::::pw:x:cell".
 */
export type CellSchema2 = {
    /**
     * CASE ( calculation == 'vc-relax' )
     */
    cell_dynamics?: "none" | "sd" | "damp-pr" | "damp-w" | "bfgs";
} | {
    /**
     * CASE ( calculation == 'vc-md' )
     */
    cell_dynamics?: "none" | "pr" | "w";
};
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:primitive:integer-one-or-zero".
 */
export type IntegerOneOrZero = number;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reference".
 */
export type ReferenceSchemaUsingAnyOfInsteadOfOneOfBelowBCCurrentReferenceSchemasOverlap = InfoForPropertyObtainedByModelingOnlySupportsExabyteOriginatedDataAtmButEasilyExtendable | InfoForCharacteristicObtainedByExperiment | LiteratureReferenceSchema;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reference:modeling".
 */
export type InfoForPropertyObtainedByModelingOnlySupportsExabyteOriginatedDataAtmButEasilyExtendable = InfoForCharacteristicObtainedByExabyteCalculation;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:primitive::d-data-series".
 */
export type DimensionDataSeriesSchema = [number | string, ...(number | string)[]][];
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:abstract::d-plot".
 */
export type DimensionPlotSchema = DimensionPlotSchema1 & DimensionPlotSchema2;
export type DimensionPlotSchema1 = DimensionDataSchema;
/**
 * @minItems 3
 * @maxItems 3
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:abstract::d-tensor".
 */
export type DimensionalTensorSchema = [
    ArrayOf3NumberElementsSchema,
    ArrayOf3NumberElementsSchema,
    ArrayOf3NumberElementsSchema
];
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:abstract:point".
 */
export type PointSchema = ArrayOf3NumberElementsSchema;
/**
 * array of strings, e.g. metadata tags
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:primitive:array-of-strings".
 */
export type ArrayOfStrings = string[];
export type BasicNodeSchemaLinkedList = BasicNodeSchemaLinkedList1 & BasicNodeSchemaLinkedList2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:primitive:linked-list:base-node".
 */
export type BasicNodeSchemaLinkedList1 = {
    /**
     * Unique flowchart ID of node
     */
    flowchartId: string;
};
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:primitive:linked-list:named-node".
 */
export type NamedNodeSchema = BasicNodeSchemaLinkedList1 & NameEntitySchema;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:primitive:linked-list:named-node-in-group".
 */
export type NamedNodeInGroupSchema = NamedNodeSchema & GroupInfoSchemaForNodesInAGraph;
export type TypedNodeSchema = TypedNodeSchema1 & TypedNodeSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:primitive:linked-list:node-with-type".
 */
export type TypedNodeSchema1 = BasicNodeSchemaLinkedList1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:primitive:linked-list".
 */
export type LinkedListSchema = (BasicNodeSchemaLinkedList | NamedNodeSchema | NamedNodeInGroupSchema | TypedNodeSchema)[];
/**
 * contains either object with slugified entry or slug only as a string
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:primitive:slugified-entry-or-slug".
 */
export type SlugifiedEntryOrSlug = SlugifiedEntry | string;
/**
 * Atomic properties per orbital pair with numeric value e.g., Hubbard V parameters.
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reusable:atomic-data-per-orbital-numeric".
 */
export type AtomicDataPerOrbitalNumeric = AtomicDataPerOrbital & AtomicDataNumericProperties;
/**
 * Atomic properties per orbital pair with numeric value e.g., Hubbard V parameters.
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reusable:atomic-data-per-orbital-pair-numeric".
 */
export type AtomicDataPerOrbitalPairNumeric = AtomicDataPerOrbitalPair & AtomicDataNumericProperties;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reusable:atomic-scalars".
 */
export type AtomicScalarsVectorsSchema = AtomicScalarsVectorsSchema1 & AtomicScalarsVectorsSchema2;
export type AtomicScalarsVectorsSchema1 = AtomicIds;
export type AtomicScalarsVectorsSchema2 = {
    value?: ScalarSchema;
}[];
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reusable:atomic-strings".
 */
export type AtomicStringsVectorsSchema = AtomicStringsVectorsSchema1 & AtomicStringsVectorsSchema2;
export type AtomicStringsVectorsSchema1 = AtomicIds;
export type AtomicStringsVectorsSchema2 = {
    value?: string;
}[];
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reusable:atomic-vectors".
 */
export type AtomicVectorsSchema = AtomicVectorsSchema1 & AtomicVectorsSchema2;
export type AtomicVectorsSchema1 = AtomicIds;
export type AtomicVectorsSchema2 = {
    value?: VectorSchema;
}[];
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reusable:band-gap".
 */
export type BandGapSchema = BandGapSchema1 & BandGapSchema2;
export type BandGapSchema1 = ScalarSchema;
/**
 * TODO: Use regex once schema draft version has been updated
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reusable:category-path".
 */
export type CategoryPathSchema = string;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reusable:dielectric-tensor-component".
 */
export type DielectricTensor = DielectricTensor1 & DielectricTensor2;
export type DielectricTensor1 = CoreReusableFrequencyFunctionMatrix;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reusable:energy".
 */
export type EnergySchema = EnergySchema1 & EnergySchema2;
export type EnergySchema1 = ScalarSchema;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "in-memory-entity:defaultable".
 */
export type DefaultableInMemoryEntitySchema = BaseInMemoryEntitySchema1 & DefaultableEntitySchema;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "in-memory-entity:named".
 */
export type NamedInMemoryEntitySchema = BaseInMemoryEntitySchema1 & NameEntitySchema;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "in-memory-entity:named-defaultable".
 */
export type NamedDefaultableInMemoryEntitySchema = BaseInMemoryEntitySchema1 & NameEntitySchema & DefaultableEntitySchema;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "method:categorized-method".
 */
export type CategorizedMethod = CategorizedMethod1 & CategorizedMethod2;
export type CategorizedMethod1 = PathEntitySchema & EntityTagsSchema;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:path-entity".
 */
export type PathEntitySchema = NameEntitySchema & PathSchema;
export type CategorizedUnitMethod = CategorizedUnitMethod1 & CategorizedUnitMethod2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "method:unit-method".
 */
export type CategorizedUnitMethod1 = PathEntitySchema & EntityTagsSchema;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "method:method-parameters".
 */
export type MethodParameters = {
    basisSlug?: "cc-pvdz" | "cc-pvtz" | "cc-pvqz";
} | {
    basisSlug?: "3-21G" | "6-31G" | "6-311G";
} | {
    basisSlug?: "sto-3g" | "sto-4g" | "sto-6g" | "def2-svp" | "def2-tzvp" | "def2-qzvp" | "cbs-qb3";
};
/**
 * Numerical differentiation category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:diff".
 */
export type MethodsCategoryMathematicalDiff = MethodsCategoryMathematicalDiff1 & {
    tier1?: "diff";
};
export type MethodsCategoryMathematicalDiff1 = Categories;
/**
 * Discretization category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:discr".
 */
export type MethodsCategoryMathematicalDiscr = MethodsCategoryMathematicalDiscr1 & {
    tier1?: "discr";
};
export type MethodsCategoryMathematicalDiscr1 = Categories;
/**
 * Unstructured meshing category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:fapprx".
 */
export type MethodsCategoryMathematicalFapprx = MethodsCategoryMathematicalFapprx1 & {
    tier1?: "fapprx";
};
export type MethodsCategoryMathematicalFapprx1 = Categories;
/**
 * Integration category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:intgr".
 */
export type MethodsCategoryMathematicalIntgr = MethodsCategoryMathematicalIntgr1 & {
    tier1?: "intgr";
};
export type MethodsCategoryMathematicalIntgr1 = Categories;
/**
 * Linear Algebra category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:linalg".
 */
export type MethodsCategoryMathematicalLinalg = MethodsCategoryMathematicalLinalg1 & {
    tier1?: "linalg";
};
export type MethodsCategoryMathematicalLinalg1 = Categories;
/**
 * Integration category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:opt".
 */
export type MethodsCategoryMathematicalOpt = MethodsCategoryMathematicalOpt1 & {
    tier1?: "opt";
};
export type MethodsCategoryMathematicalOpt1 = Categories;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:regression".
 */
export type LinearMethodsCategorySchema = LinearMethodsCategorySchema1 & LinearMethodsCategorySchema2;
export type LinearMethodsCategorySchema1 = Categories;
/**
 * Finite difference method category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:diff:fd".
 */
export type MethodsCategoryMathematicalDiffFd = MethodsCategoryMathematicalDiffFd1 & {
    tier2?: "fd";
};
export type MethodsCategoryMathematicalDiffFd1 = MethodsCategoryMathematicalDiff1;
/**
 * Meshing method category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:discr:mesh".
 */
export type MethodsCategoryMathematicalDiscrMesh = MethodsCategoryMathematicalDiscrMesh1 & {
    tier2?: "mesh";
};
export type MethodsCategoryMathematicalDiscrMesh1 = MethodsCategoryMathematicalDiscr1;
/**
 * Hybrid meshing category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:discr:mesh:hybrid".
 */
export type MethodsCategoryMathematicalDiscrMeshHybrid = MethodsCategoryMathematicalDiscrMeshHybrid1 & {
    tier3?: "hybrid";
};
export type MethodsCategoryMathematicalDiscrMeshHybrid1 = MethodsCategoryMathematicalDiscrMesh1;
/**
 * Unstructured meshing category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:discr:mesh:nstruct".
 */
export type MethodsCategoryMathematicalDiscrMeshNstruct = MethodsCategoryMathematicalDiscrMeshNstruct1 & {
    tier3?: "nstruct";
};
export type MethodsCategoryMathematicalDiscrMeshNstruct1 = MethodsCategoryMathematicalDiscrMesh1;
/**
 * Structured meshing category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:discr:mesh:struct".
 */
export type MethodsCategoryMathematicalDiscrMeshStruct = MethodsCategoryMathematicalDiscrMeshStruct1 & {
    tier3?: "struct";
};
export type MethodsCategoryMathematicalDiscrMeshStruct1 = MethodsCategoryMathematicalDiscrMesh1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:discr:mesh:struct:cartesian".
 */
export type CartesianGridSchema = CartesianGridSchema1 & CartesianGridSchema2;
export type CartesianGridSchema1 = MethodsCategoryMathematicalDiscrMeshStruct1;
/**
 * Basis expansion category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:fapprx:basisexp".
 */
export type MethodsCategoryMathematicalFapprxBasisexp = MethodsCategoryMathematicalFapprxBasisexp1 & {
    tier2?: "basisExp";
};
export type MethodsCategoryMathematicalFapprxBasisexp1 = MethodsCategoryMathematicalFapprx1;
/**
 * Interpolation category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:fapprx:ipol".
 */
export type MethodsCategoryMathematicalFapprxIpol = MethodsCategoryMathematicalFapprxIpol1 & {
    tier2?: "ipol";
};
export type MethodsCategoryMathematicalFapprxIpol1 = MethodsCategoryMathematicalFapprx1;
/**
 * Linear interpolation category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:fapprx:ipol:lin".
 */
export type MethodsCategoryMathematicalFapprxIpolLin = MethodsCategoryMathematicalFapprxIpolLin1 & {
    tier3?: "lin";
};
export type MethodsCategoryMathematicalFapprxIpolLin1 = MethodsCategoryMathematicalFapprxIpol1;
/**
 * Polynomial interpolation category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:fapprx:ipol:poly".
 */
export type MethodsCategoryMathematicalFapprxIpolPoly = MethodsCategoryMathematicalFapprxIpolPoly1 & {
    tier3?: "poly";
};
export type MethodsCategoryMathematicalFapprxIpolPoly1 = MethodsCategoryMathematicalFapprxIpol1;
/**
 * Spline interpolation category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:fapprx:ipol:spline".
 */
export type MethodsCategoryMathematicalFapprxIpolSpline = MethodsCategoryMathematicalFapprxIpolSpline1 & {
    tier3?: "spline";
};
export type MethodsCategoryMathematicalFapprxIpolSpline1 = MethodsCategoryMathematicalFapprxIpol1;
/**
 * Analytic integral category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:intgr:analytic".
 */
export type MethodsCategoryMathematicalIntgrAnalytic = MethodsCategoryMathematicalIntgrAnalytic1 & {
    tier2?: "analytic";
};
export type MethodsCategoryMathematicalIntgrAnalytic1 = MethodsCategoryMathematicalIntgr1;
/**
 * Methods for the numerical integration of differential equations
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:intgr:diffeq".
 */
export type MethodsCategoryMathematicalIntgrDiffeq = MethodsCategoryMathematicalIntgrDiffeq1 & {
    tier2?: "diffeq";
};
export type MethodsCategoryMathematicalIntgrDiffeq1 = MethodsCategoryMathematicalIntgr1;
/**
 * Methods for the numerical quadrature
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:intgr:numquad".
 */
export type MethodsCategoryMathematicalIntgrNumquad = MethodsCategoryMathematicalIntgrNumquad1 & {
    tier2?: "numquad";
};
export type MethodsCategoryMathematicalIntgrNumquad1 = MethodsCategoryMathematicalIntgr1;
/**
 * Integral transform methods
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:intgr:transf".
 */
export type MethodsCategoryMathematicalIntgrTransf = MethodsCategoryMathematicalIntgrTransf1 & {
    tier2?: "transf";
};
export type MethodsCategoryMathematicalIntgrTransf1 = MethodsCategoryMathematicalIntgr1;
/**
 * analytic volume integral category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:intgr:analytic:volume".
 */
export type MethodsCategoryMathematicalIntgrAnalyticVolume = MethodsCategoryMathematicalIntgrAnalyticVolume1 & {
    type?: "volume";
    subtype?: "sphere" | "cube" | "rect-prism" | "tri-prism" | "cylinder" | "cone" | "tetrahedron" | "sq-pyr";
};
export type MethodsCategoryMathematicalIntgrAnalyticVolume1 = MethodsCategoryMathematicalIntgrAnalytic1;
/**
 * Categories for the numerical integration of differential equations
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:intgr:diffeq:order:".
 */
export type MethodsCategoryMathematicalIntgrDiffeqOrder2 = MethodsCategoryMathematicalIntgrDiffeqOrder & {
    tier3?: "order2";
};
export type MethodsCategoryMathematicalIntgrDiffeqOrder = MethodsCategoryMathematicalIntgrDiffeq1;
/**
 * Gaussian quadrature rules
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:intgr:numquad:gauss".
 */
export type MethodsCategoryMathematicalIntgrNumquadGauss = MethodsCategoryMathematicalIntgrNumquadGauss1 & {
    tier3?: "gauss";
};
export type MethodsCategoryMathematicalIntgrNumquadGauss1 = MethodsCategoryMathematicalIntgrNumquad1;
/**
 * Newton-Cotes quadrature rules
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:intgr:numquad:newcot".
 */
export type MethodsCategoryMathematicalIntgrNumquadNewcot = MethodsCategoryMathematicalIntgrNumquadNewcot1 & {
    tier3?: "newcot";
};
export type MethodsCategoryMathematicalIntgrNumquadNewcot1 = MethodsCategoryMathematicalIntgrNumquad1;
/**
 * Fourier transform methods
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:intgr:transf:fourier".
 */
export type MethodsCategoryMathematicalIntgrTransfFourier = MethodsCategoryMathematicalIntgrTransfFourier1 & {
    type?: "fourier";
};
export type MethodsCategoryMathematicalIntgrTransfFourier1 = MethodsCategoryMathematicalIntgrTransf1;
/**
 * Matrix decomposition methods
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:linalg:dcomp".
 */
export type MethodsCategoryMathematicalLinalgDcomp = MethodsCategoryMathematicalLinalgDcomp1 & {
    tier2?: "dcomp";
};
export type MethodsCategoryMathematicalLinalgDcomp1 = MethodsCategoryMathematicalLinalg1;
/**
 * Matrix diagonalization methods
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:linalg:diag".
 */
export type MethodsCategoryMathematicalLinalgDiag = MethodsCategoryMathematicalLinalgDiag1 & {
    tier2?: "diag";
};
export type MethodsCategoryMathematicalLinalgDiag1 = MethodsCategoryMathematicalLinalg1;
/**
 * Linear transformation methods
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:linalg:lintra".
 */
export type MethodsCategoryMathematicalLinalgLintra = MethodsCategoryMathematicalLinalgLintra1 & {
    tier2?: "lintra";
};
export type MethodsCategoryMathematicalLinalgLintra1 = MethodsCategoryMathematicalLinalg1;
/**
 * Matrix function methods
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:linalg:matf".
 */
export type MethodsCategoryMathematicalLinalgMatf = MethodsCategoryMathematicalLinalgMatf1 & {
    tier2?: "matf";
};
export type MethodsCategoryMathematicalLinalgMatf1 = MethodsCategoryMathematicalLinalg1;
/**
 * Davidson diagonalization method
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:linalg:diag:davidson".
 */
export type MethodsCategoryMathematicalLinalgDiagDavidson = MethodsCategoryMathematicalLinalgDiagDavidson1 & {
    type?: "davidson";
};
export type MethodsCategoryMathematicalLinalgDiagDavidson1 = MethodsCategoryMathematicalLinalgDiag1;
/**
 * Optimization methods for differentiable functions category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:opt:diff".
 */
export type MethodsCategoryMathematicalOptDiff = MethodsCategoryMathematicalOptDiff1 & {
    tier2?: "diff";
};
export type MethodsCategoryMathematicalOptDiff1 = MethodsCategoryMathematicalOpt1;
/**
 * Optimization methods for non-differentiable functions category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:opt:ndiff".
 */
export type MethodsCategoryMathematicalOptNdiff = MethodsCategoryMathematicalOptNdiff1 & {
    tier2?: "ndiff";
};
export type MethodsCategoryMathematicalOptNdiff1 = MethodsCategoryMathematicalOpt1;
/**
 * Root finding category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:opt:root".
 */
export type MethodsCategoryMathematicalOptRoot = MethodsCategoryMathematicalOptRoot1 & {
    tier2?: "root";
};
export type MethodsCategoryMathematicalOptRoot1 = MethodsCategoryMathematicalOpt1;
/**
 * Bracket algorithms for the optimization of differentiable functions
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:opt:diff:bracket".
 */
export type MethodsCategoryMathematicalOptDiffBracket = MethodsCategoryMathematicalOptDiffBracket1 & {
    tier3?: "bracket";
};
export type MethodsCategoryMathematicalOptDiffBracket1 = MethodsCategoryMathematicalOptDiff1;
/**
 * Local descent methods for the optimization of differentiable functions
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:opt:diff:local".
 */
export type MethodsCategoryMathematicalOptDiffLocal = MethodsCategoryMathematicalOptDiffLocal1 & {
    tier3?: "local";
};
export type MethodsCategoryMathematicalOptDiffLocal1 = MethodsCategoryMathematicalOptDiff1;
/**
 * Second order algorithms for the optimization of differentiable functions
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:opt:diff:order:".
 */
export type MethodsCategoryMathematicalOptDiffOrder2 = MethodsCategoryMathematicalOptDiffOrder & {
    tier3?: "order2";
};
export type MethodsCategoryMathematicalOptDiffOrder = MethodsCategoryMathematicalOptDiff1;
/**
 * Mixed order and higher order algorithms for the optimization of differentiable functions
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:opt:diff:ordern".
 */
export type MethodsCategoryMathematicalOptDiffOrdern = MethodsCategoryMathematicalOptDiffOrdern1 & {
    tier3?: "ordern";
};
export type MethodsCategoryMathematicalOptDiffOrdern1 = MethodsCategoryMathematicalOptDiff1;
/**
 * conjugate gradient method schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:opt:diff:ordern:cg".
 */
export type MethodsCategoryMathematicalOptDiffOrdernCg = MethodsCategoryMathematicalOptDiffOrdernCg1 & {
    type?: "cg";
};
export type MethodsCategoryMathematicalOptDiffOrdernCg1 = MethodsCategoryMathematicalOptDiffOrdern1;
/**
 * Direct algorithms for the optimization of non-differentiable functions category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:opt:ndiff:direct".
 */
export type MethodsCategoryMathematicalOptNdiffDirect = MethodsCategoryMathematicalOptNdiffDirect1 & {
    tier3?: "direct";
};
export type MethodsCategoryMathematicalOptNdiffDirect1 = MethodsCategoryMathematicalOptNdiff1;
/**
 * Population algorithms for the optmization of non-differentiable functions category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:opt:ndiff:pop".
 */
export type MethodsCategoryMathematicalOptNdiffPop = MethodsCategoryMathematicalOptNdiffPop1 & {
    tier3?: "pop";
};
export type MethodsCategoryMathematicalOptNdiffPop1 = MethodsCategoryMathematicalOptNdiff1;
/**
 * Stochastic algorithms for the optmization of non-differentiable functions category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:opt:ndiff:stoch".
 */
export type MethodsCategoryMathematicalOptNdiffStoch = MethodsCategoryMathematicalOptNdiffStoch1 & {
    tier3?: "stoch";
};
export type MethodsCategoryMathematicalOptNdiffStoch1 = MethodsCategoryMathematicalOptNdiff1;
/**
 * Bracketing method for finding roots category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:opt:root:bracket".
 */
export type MethodsCategoryMathematicalOptRootBracket = MethodsCategoryMathematicalOptRootBracket1 & {
    tier3?: "bracket";
};
export type MethodsCategoryMathematicalOptRootBracket1 = MethodsCategoryMathematicalOptRoot1;
/**
 * Iterative method for root finding category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:opt:root:iter".
 */
export type MethodsCategoryMathematicalOptRootIter = MethodsCategoryMathematicalOptRootIter1 & {
    tier3?: "iterative";
};
export type MethodsCategoryMathematicalOptRootIter1 = MethodsCategoryMathematicalOptRoot1;
/**
 * Quantum-Mechanical method category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:physical:qm".
 */
export type MethodsCategoryPhysicalQm = MethodsCategoryPhysicalQm1 & {
    tier1?: "qm";
};
export type MethodsCategoryPhysicalQm1 = Categories;
/**
 * Methods related to wave functions
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:physical:qm:wf".
 */
export type MethodsCategoryPhysicalQmWf = MethodsCategoryPhysicalQmWf1 & {
    tier2?: "wf";
};
export type MethodsCategoryPhysicalQmWf1 = MethodsCategoryPhysicalQm1;
/**
 * Approximating the electronic wave function with a atomic orbital basis
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:physical:qm:wf:ao".
 */
export type MethodsCategoryPhysicalQmWfAo = MethodsCategoryPhysicalQmWfAo1 & {
    type?: "ao";
    subtype?: "pople" | "dunning" | "other";
};
export type MethodsCategoryPhysicalQmWfAo1 = MethodsCategoryPhysicalQmWf1;
/**
 * Pseudopotential category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:physical:qm:wf:psp".
 */
export type MethodsCategoryPhysicalQmWfPsp = MethodsCategoryPhysicalQmWfPsp1 & {
    type?: "psp";
    subtype?: "us" | "nc" | "paw" | "coulomb";
};
export type MethodsCategoryPhysicalQmWfPsp1 = MethodsCategoryPhysicalQmWf1;
/**
 * Plane wave catgeory schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:physical:qm:wf:pw".
 */
export type MethodsCategoryPhysicalQmWfPw = MethodsCategoryPhysicalQmWfPw1 & {
    type?: "pw";
};
export type MethodsCategoryPhysicalQmWfPw1 = MethodsCategoryPhysicalQmWf1;
/**
 * Approximating Heaviside step function with smooth function
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:physical:qm:wf:smearing".
 */
export type SmearingMethodsCategorySchema = SmearingMethodsCategorySchema1 & SmearingMethodsCategorySchema2;
export type SmearingMethodsCategorySchema1 = MethodsCategoryPhysicalQmWf1;
/**
 * Tetrahedron method for Brillouin zone integration category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:physical:qm:wf:tetrahedron".
 */
export type MethodsCategoryPhysicalQmWfTetrahedron = MethodsCategoryPhysicalQmWfTetrahedron1 & {
    type?: "tetrahedron";
    subtype?: "linear" | "optimized" | "bloechl";
};
export type MethodsCategoryPhysicalQmWfTetrahedron1 = MethodsCategoryPhysicalQmWf1;
/**
 * Dunning correlation-consistent basis set category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:physical:qm:wf:ao:dunning".
 */
export type MethodsCategoryPhysicalQmWfAoDunning = MethodsCategoryPhysicalQmWfAoDunning1 & {
    subtype?: "dunning";
};
export type MethodsCategoryPhysicalQmWfAoDunning1 = MethodsCategoryPhysicalQmWfAo1;
/**
 * Other (neither Pople nor Dunning) basis set category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:physical:qm:wf:ao:other".
 */
export type MethodsCategoryPhysicalQmWfAoOther = MethodsCategoryPhysicalQmWfAoOther1 & {
    subtype?: "other";
};
export type MethodsCategoryPhysicalQmWfAoOther1 = MethodsCategoryPhysicalQmWfAo1;
/**
 * Pople basis set category schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:physical:qm:wf:ao:pople".
 */
export type MethodsCategoryPhysicalQmWfAoPople = MethodsCategoryPhysicalQmWfAoPople1 & {
    subtype?: "pople";
};
export type MethodsCategoryPhysicalQmWfAoPople1 = MethodsCategoryPhysicalQmWfAo1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:legacy:localorbital".
 */
export type LegacyMethodLocalorbital = LegacyMethodLocalorbital1 & LegacyMethodLocalorbital2;
export type LegacyMethodLocalorbital1 = BaseMethod;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:legacy:pseudopotential".
 */
export type LegacyMethodPseudopotential = LegacyMethodPseudopotential1 & LegacyMethodPseudopotential2;
export type LegacyMethodPseudopotential1 = BaseMethod;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:legacy:regression".
 */
export type LegacyMethodRegression = LegacyMethodRegression1 & LegacyMethodRegression2;
export type LegacyMethodRegression1 = BaseMethod;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:legacy:unknown".
 */
export type LegacyMethodUnknown = LegacyMethodUnknown1 & LegacyMethodUnknown2;
export type LegacyMethodUnknown1 = BaseMethod;
/**
 * conjugate gradient method schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:mathematical:cg".
 */
export type UnitMethodConjugateGradient = UnitMethodConjugateGradient1 & UnitMethodConjugateGradient2;
export type UnitMethodConjugateGradient1 = CategorizedUnitMethod1;
/**
 * Davidson diagonalization method
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:mathematical:davidson".
 */
export type UnitMethodDavidson = UnitMethodDavidson1 & UnitMethodDavidson2;
export type UnitMethodDavidson1 = CategorizedUnitMethod1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:mathematical:regression".
 */
export type UnitMethodRegression = UnitMethodRegression1 & UnitMethodRegression2;
export type UnitMethodRegression1 = CategorizedUnitMethod1;
/**
 * Core-valence separation by means of pseudopotentials (effective potential)
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:physical:psp".
 */
export type UnitMethodPseudopotential = UnitMethodPseudopotential1 & UnitMethodPseudopotential2;
export type UnitMethodPseudopotential1 = CategorizedUnitMethod1;
/**
 * Approximating the electronic wave function with a plane wave basis
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:physical:pw".
 */
export type UnitMethodPlaneWave = UnitMethodPlaneWave1 & UnitMethodPlaneWave2;
export type UnitMethodPlaneWave1 = CategorizedUnitMethod1;
/**
 * Approximating Heaviside step function with smooth function
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:physical:smearing".
 */
export type UnitMethodSmearing = UnitMethodSmearing1 & UnitMethodSmearing2;
export type UnitMethodSmearing1 = CategorizedUnitMethod1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:physical:tetrahedron".
 */
export type UnitMethodTetrahedron = UnitMethodTetrahedron1 & UnitMethodTetrahedron2;
export type UnitMethodTetrahedron1 = CategorizedUnitMethod1;
/**
 * Dunning correlation-consistent basis set unit method
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:physical:ao:dunning".
 */
export type UnitMethodAoDunning = UnitMethodAoDunning1 & UnitMethodAoDunning2;
export type UnitMethodAoDunning1 = CategorizedUnitMethod1;
/**
 * Other (neither Pople nor Dunning) basis set unit method
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:physical:ao:other".
 */
export type UnitMethodAoOther = UnitMethodAoOther1 & UnitMethodAoOther2;
export type UnitMethodAoOther1 = CategorizedUnitMethod1;
/**
 * Pople basis set unit method
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:physical:ao:pople".
 */
export type UnitMethodAoPople = UnitMethodAoPople1 & UnitMethodAoPople2;
export type UnitMethodAoPople1 = CategorizedUnitMethod1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "model:categorized-model".
 */
export type CategorizedModel = CategorizedModel1 & CategorizedModel2;
export type CategorizedModel1 = ModelWithoutMethodSchemaBase;
export type ModelWithoutMethodSchemaBase = ModelWithoutMethodSchemaBase1 & ModelWithoutMethodSchemaBase2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "model:model-without-method".
 */
export type ModelWithoutMethodSchemaBase1 = PathEntitySchema & EntityTagsSchema;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "model:model-parameters".
 */
export type ModelParameters = HubbardModelMixin & SpinPolarizationMixin & SpinOrbitCouplingMixin & DispersionCorrectionMixin & (LDAFunctionalMixin | GGAFunctionalMixin | MetaGGAFunctionalMixin | HybridFunctionalMixin | DoubleHybridFunctionalMixin);
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:pb".
 */
export type PhysicsBasedModelCategorySchema = PhysicsBasedModelCategorySchema1 & PhysicsBasedModelCategorySchema2;
export type PhysicsBasedModelCategorySchema1 = Categories;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:st".
 */
export type StatisticalModelCategorySchema = StatisticalModelCategorySchema1 & StatisticalModelCategorySchema2;
export type StatisticalModelCategorySchema1 = Categories;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:pb:qm".
 */
export type QuantumMechanicalCategorySchema = QuantumMechanicalCategorySchema1 & QuantumMechanicalCategorySchema2;
export type QuantumMechanicalCategorySchema1 = PhysicsBasedModelCategorySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:pb:qm:abin".
 */
export type AbInitioCategorySchema = AbInitioCategorySchema1 & AbInitioCategorySchema2;
export type AbInitioCategorySchema1 = QuantumMechanicalCategorySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:pb:qm:dft".
 */
export type DensityFunctionalTheoryCategorySchema = DensityFunctionalTheoryCategorySchema1 & DensityFunctionalTheoryCategorySchema2;
export type DensityFunctionalTheoryCategorySchema1 = QuantumMechanicalCategorySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:pb:qm:semp".
 */
export type SemiEmpiricalCategorySchema = SemiEmpiricalCategorySchema1 & SemiEmpiricalCategorySchema2;
export type SemiEmpiricalCategorySchema1 = QuantumMechanicalCategorySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:pb:qm:abin:gw".
 */
export type GWCategorySchema = GWCategorySchema1 & GWCategorySchema2;
export type GWCategorySchema1 = AbInitioCategorySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:pb:qm:dft:ksdft".
 */
export type KohnShamDFTCategorySchema = KohnShamDFTCategorySchema1 & KohnShamDFTCategorySchema2;
export type KohnShamDFTCategorySchema1 = DensityFunctionalTheoryCategorySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:pb:qm:dft:ksdft:double-hybrid".
 */
export type DFTDoubleHybridFunctionalCategorySchema = DFTDoubleHybridFunctionalCategorySchema1 & DFTDoubleHybridFunctionalCategorySchema2;
export type DFTDoubleHybridFunctionalCategorySchema1 = KohnShamDFTCategorySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:pb:qm:dft:ksdft:gga".
 */
export type DFTGGAFunctionalCategorySchema = DFTGGAFunctionalCategorySchema1 & DFTGGAFunctionalCategorySchema2;
export type DFTGGAFunctionalCategorySchema1 = KohnShamDFTCategorySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:pb:qm:dft:ksdft:hybrid".
 */
export type DFTHybridFunctionalCategorySchema = DFTHybridFunctionalCategorySchema1 & DFTHybridFunctionalCategorySchema2;
export type DFTHybridFunctionalCategorySchema1 = KohnShamDFTCategorySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:pb:qm:dft:ksdft:lda".
 */
export type DFTLDAFunctionalCategorySchema = DFTLDAFunctionalCategorySchema1 & DFTLDAFunctionalCategorySchema2;
export type DFTLDAFunctionalCategorySchema1 = KohnShamDFTCategorySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:pb:qm:dft:ksdft:mgga".
 */
export type DFTMetaGGAFunctionalCategorySchema = DFTMetaGGAFunctionalCategorySchema1 & DFTMetaGGAFunctionalCategorySchema2;
export type DFTMetaGGAFunctionalCategorySchema1 = KohnShamDFTCategorySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:st:det".
 */
export type DeterministicModelCategorySchema = DeterministicModelCategorySchema1 & DeterministicModelCategorySchema2;
export type DeterministicModelCategorySchema1 = StatisticalModelCategorySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:st:det:ml".
 */
export type MachineLearningModelCategorySchema = MachineLearningModelCategorySchema1 & MachineLearningModelCategorySchema2;
export type MachineLearningModelCategorySchema1 = DeterministicModelCategorySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:st:det:ml:re".
 */
export type RegressionModelCategorySchema = RegressionModelCategorySchema1 & RegressionModelCategorySchema2;
export type RegressionModelCategorySchema1 = MachineLearningModelCategorySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-directory:double-hybrid".
 */
export type ModelDoubleHybridFunctional = ModelDoubleHybridFunctional1 & ModelDoubleHybridFunctional2;
export type ModelDoubleHybridFunctional1 = ModelWithoutMethodSchemaBase1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-directory:gga".
 */
export type ModelGeneralizedGradientApproximation = ModelGeneralizedGradientApproximation1 & ModelGeneralizedGradientApproximation2;
export type ModelGeneralizedGradientApproximation1 = ModelWithoutMethodSchemaBase1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-directory:gw".
 */
export type ModelGwApproximation = ModelGwApproximation1 & ModelGwApproximation2;
export type ModelGwApproximation1 = ModelWithoutMethodSchemaBase1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-directory:hybrid".
 */
export type ModelHybridFunctional = ModelHybridFunctional1 & ModelHybridFunctional2;
export type ModelHybridFunctional1 = ModelWithoutMethodSchemaBase1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-directory:lda".
 */
export type ModelLocalDensityApproximation = ModelLocalDensityApproximation1 & ModelLocalDensityApproximation2;
export type ModelLocalDensityApproximation1 = ModelWithoutMethodSchemaBase1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-directory:mgga".
 */
export type ModelMetaGeneralizedGradientApproximation = ModelMetaGeneralizedGradientApproximation1 & ModelMetaGeneralizedGradientApproximation2;
export type ModelMetaGeneralizedGradientApproximation1 = ModelWithoutMethodSchemaBase1;
/**
 * machine learning model type/subtype schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-directory:re".
 */
export type ModelRegression = ModelRegression1 & ModelRegression2;
export type ModelRegression1 = ModelWithoutMethodSchemaBase1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-directory:legacy:dft".
 */
export type LegacyModelDensityFunctionalTheory = LegacyModelDensityFunctionalTheory1 & LegacyModelDensityFunctionalTheory2;
export type LegacyModelDensityFunctionalTheory1 = BaseModel & ({
    subtype?: "lda";
    functional?: "pz" | "pw" | "vwn" | "other";
} | {
    subtype?: "gga";
    functional?: "pbe" | "pbesol" | "pw91" | "other";
} | {
    subtype?: "hybrid";
    functional?: "b3lyp" | "hse06";
});
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-directory:legacy:ml".
 */
export type LegacyModelRegression = LegacyModelRegression1 & LegacyModelRegression2;
export type LegacyModelRegression1 = BaseModel;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-directory:legacy:unknown".
 */
export type LegacyModelUnknown = LegacyModelUnknown1 & LegacyModelUnknown2;
export type LegacyModelUnknown1 = BaseModel;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:non-scalar:average-potential-profile".
 */
export type AveragePotentialProfileSchema = AveragePotentialProfileSchema1 & AveragePotentialProfileSchema2;
export type AveragePotentialProfileSchema1 = DimensionPlotSchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:non-scalar:band-structure".
 */
export type BandStructureSchema = BandStructureSchema1 & BandStructureSchema2;
export type BandStructureSchema1 = DimensionPlotSchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:non-scalar:charge-density-profile".
 */
export type ChargeDensityProfileSchema = ChargeDensityProfileSchema1 & ChargeDensityProfileSchema2;
export type ChargeDensityProfileSchema1 = DimensionPlotSchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:non-scalar:density-of-states".
 */
export type DensityOfStatesSchema = DensityOfStatesSchema1 & DensityOfStatesSchema2;
export type DensityOfStatesSchema1 = DimensionPlotSchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:non-scalar:file-content".
 */
export type FileContent = FileContent1 & FileContent2;
export type FileContent1 = FileMetadata;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:non-scalar:phonon-dispersions".
 */
export type PhononBandStructureSchema = PhononBandStructureSchema1 & PhononBandStructureSchema2;
export type PhononBandStructureSchema1 = DimensionPlotSchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:non-scalar:phonon-dos".
 */
export type PhononDensityOfStatesSchema = PhononDensityOfStatesSchema1 & PhononDensityOfStatesSchema2;
export type PhononDensityOfStatesSchema1 = DimensionPlotSchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:non-scalar:potential-profile".
 */
export type PotentialProfileSchema = PotentialProfileSchema1 & PotentialProfileSchema2;
export type PotentialProfileSchema1 = DimensionPlotSchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:non-scalar:reaction-energy-profile".
 */
export type ReactionEnergyProfileSchema = ReactionEnergyProfileSchema1 & ReactionEnergyProfileSchema2;
export type ReactionEnergyProfileSchema1 = DimensionPlotSchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:non-scalar:vibrational-spectrum".
 */
export type VibrationalSpectrumSchema = VibrationalSpectrumSchema1 & VibrationalSpectrumSchema2;
export type VibrationalSpectrumSchema1 = DimensionPlotSchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:scalar:electron-affinity".
 */
export type ElectronAffinitySchema = ElectronAffinitySchema1 & ElectronAffinitySchema2;
export type ElectronAffinitySchema1 = EnergySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:scalar:fermi-energy".
 */
export type FermiEnergySchema = FermiEnergySchema1 & FermiEnergySchema2;
export type FermiEnergySchema1 = EnergySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:scalar:formation-energy".
 */
export type FormationEnergySchema = FormationEnergySchema1 & FormationEnergySchema2;
export type FormationEnergySchema1 = EnergySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:scalar:ionization-potential".
 */
export type IonizationPotentialSchema = IonizationPotentialSchema1 & IonizationPotentialSchema2;
export type IonizationPotentialSchema1 = EnergySchema1;
/**
 * average pressure in unit cell
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:scalar:pressure".
 */
export type Pressure = Pressure1 & Pressure2;
export type Pressure1 = ScalarSchema;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:scalar:reaction-energy-barrier".
 */
export type ReactionEnergyBarrierSchema = ReactionEnergyBarrierSchema1 & ReactionEnergyBarrierSchema2;
export type ReactionEnergyBarrierSchema1 = EnergySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:scalar:surface-energy".
 */
export type SurfaceEnergySchema = SurfaceEnergySchema1 & SurfaceEnergySchema2;
export type SurfaceEnergySchema1 = EnergySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:scalar:total-energy".
 */
export type TotalEnergySchema = TotalEnergySchema1 & TotalEnergySchema2;
export type TotalEnergySchema1 = EnergySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:scalar:total-force".
 */
export type TotalForcesSchema = TotalForcesSchema1 & TotalForcesSchema2;
export type TotalForcesSchema1 = ScalarSchema;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:scalar:valence-band-offset".
 */
export type ValenceBandOffsetSchema = ValenceBandOffsetSchema1 & ValenceBandOffsetSchema2;
export type ValenceBandOffsetSchema1 = EnergySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:scalar:zero-point-energy".
 */
export type ZeroPointEnergySchema = ZeroPointEnergySchema1 & ZeroPointEnergySchema2;
export type ZeroPointEnergySchema1 = EnergySchema1;
export type AtomicVectorsSchema3 = AtomicVectorsSchema1 & AtomicVectorsSchema2;
export type AtomicVectorsSchema4 = AtomicVectorsSchema1 & AtomicVectorsSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:molecular-pattern".
 */
export type MolecularPatternSchema = (FunctionalGroupPatternSchema | RingPatternSchema | SpecialBondPatternSchema)[];
export type AtomicVectorsSchema5 = AtomicVectorsSchema1 & AtomicVectorsSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:lattice:type-extended-enum".
 */
export type LatticeTypeExtendedSchema = "BCC" | "BCT-1" | "BCT-2" | "CUB" | "FCC" | "HEX" | "MCL" | "MCLC-1" | "MCLC-2" | "MCLC-3" | "MCLC-4" | "MCLC-5" | "ORC" | "ORCC" | "ORCF-1" | "ORCF-2" | "ORCF-3" | "ORCI" | "RHL-1" | "RHL-2" | "TET" | "TRI_1a" | "TRI_2a" | "TRI_1b";
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "property:base".
 */
export type SchemaOfBaseMaterialSPreliminaryProperty = SchemaOfBaseMaterialSPreliminaryProperty1 & SchemaOfBaseMaterialSPreliminaryProperty2;
export type SchemaOfBaseMaterialSPreliminaryProperty1 = BaseInMemoryEntitySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "property:meta".
 */
export type SchemaOfMaterialSMetaProperties = SchemaOfMaterialSPreliminaryProperty;
export type SchemaOfMaterialSPreliminaryProperty = SchemaOfMaterialSPreliminaryProperty1 & SchemaOfMaterialSPreliminaryProperty2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "property:raw".
 */
export type SchemaOfMaterialSPreliminaryProperty1 = BaseInMemoryEntitySchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software:template".
 */
export type TemplateSchema = TemplateSchema1 & TemplateSchema2;
export type TemplateSchema1 = ExecutionUnitInputItemSchemaForPhysicsBasedSimulationEngines;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:ml:unit:execution".
 */
export type SoftwareDirectoryMlUnitExecution = CrossValidationUnitSchema | TrainUnitSchema | TrainScoreSchema | InitializeUnitSchema;
export type CrossValidationUnitSchema = CrossValidationUnitSchema1 & CrossValidationUnitSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:ml:unit:execution:evaluate:cross-validate".
 */
export type CrossValidationUnitSchema1 = ExecutionUnitSchemaBase1;
export type TrainUnitSchema = TrainUnitSchema1 & TrainUnitSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:ml:unit:execution:train".
 */
export type TrainUnitSchema1 = ExecutionUnitSchemaBase1;
export type TrainScoreSchema = TrainScoreSchema1 & TrainScoreSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:ml:unit:execution:score".
 */
export type TrainScoreSchema1 = ExecutionUnitSchemaBase1;
export type InitializeUnitSchema = InitializeUnitSchema1 & InitializeUnitSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:ml:unit:execution:initialize".
 */
export type InitializeUnitSchema1 = ExecutionUnitSchemaBase1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:ml:unit:processing".
 */
export type SoftwareDirectoryMlUnitProcessing = SoftwareDirectoryMlUnitProcessingDataTransformation | SoftwareDirectoryMlUnitProcessingFeatureSelection;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:ml:unit:processing:data-transformation".
 */
export type SoftwareDirectoryMlUnitProcessingDataTransformation = ScaleAndReduceUnitSchema;
export type ScaleAndReduceUnitSchema = ScaleAndReduceUnitSchema1 & ScaleAndReduceUnitSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:ml:unit:processing:data-transformation:scale-and-reduce".
 */
export type ScaleAndReduceUnitSchema1 = ProcessingUnitSchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:ml:unit:processing:feature-selection".
 */
export type SoftwareDirectoryMlUnitProcessingFeatureSelection = FilterBasedFeatureSelectionUnitSchema;
export type FilterBasedFeatureSelectionUnitSchema = FilterBasedFeatureSelectionUnitSchema1 & FilterBasedFeatureSelectionUnitSchema2;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:ml:unit:processing:feature-selection:filter-based".
 */
export type FilterBasedFeatureSelectionUnitSchema1 = ProcessingUnitSchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:ml:unit:processing:data-transformation:manipulation".
 */
export type ManipulationUnitSchema = ManipulationUnitSchema1 & ManipulationUnitSchema2;
export type ManipulationUnitSchema1 = ProcessingUnitSchema1;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:modeling:nwchem".
 */
export type NWChem = NWChem1 & NWChem2;
export type NWChem1 = ApplicationSchemaBase;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:modeling:vasp".
 */
export type ViennaAbInitoSimulationPackage = ViennaAbInitoSimulationPackage1 & ViennaAbInitoSimulationPackage2;
export type ViennaAbInitoSimulationPackage1 = ApplicationSchemaBase;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:modeling:unit:execution".
 */
export type ExecutionUnitSchemaForPhysicsBasedSimulationEnginesDefinedUsingEspressoAsExample = ExecutionUnitSchemaBase1 & ExecutionUnitInputSchemaForPhysicsBasedSimulationEngines;
export type ExecutionUnitInputSchema1 = (ExecutionUnitInputItemSchemaForPhysicsBasedSimulationEngines | ExecutionUnitInputIdItemSchemaForPhysicsBasedSimulationEngines)[];
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:scripting:jupyter-lab".
 */
export type JupyterLabApplicationSchema = JupyterLabApplicationSchema1 & JupyterLabApplicationSchema2;
export type JupyterLabApplicationSchema1 = ApplicationSchemaBase;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:scripting:python".
 */
export type PythonProgramingLanguageSchema = PythonProgramingLanguageSchema1 & PythonProgramingLanguageSchema2;
export type PythonProgramingLanguageSchema1 = ApplicationSchemaBase;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:scripting:shell".
 */
export type ShellScriptingLanguageSchema = ShellScriptingLanguageSchema1 & ShellScriptingLanguageSchema2;
export type ShellScriptingLanguageSchema1 = ApplicationSchemaBase;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:scripting:unit:execution".
 */
export type ExecutionUnitSchemaForScriptingBasedApplications = ExecutionUnitSchemaBase1 & ExecutionUnitInputSchemaForPhysicsBasedSimulationEngines;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:-material".
 */
export type MaterialEntityReferenceSchema = MaterialEntityReferenceSchema1 & MaterialEntityReferenceSchema2;
export type MaterialEntityReferenceSchema1 = EntityReferenceSchema;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:-parent-job".
 */
export type ParentJobEntityReferenceSchema = ParentJobEntityReferenceSchema1 & ParentJobEntityReferenceSchema2;
export type ParentJobEntityReferenceSchema1 = EntityReferenceSchema;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:-project".
 */
export type ProjectEntityReferenceSchema = ProjectEntityReferenceSchema1 & ProjectEntityReferenceSchema2;
export type ProjectEntityReferenceSchema1 = EntityReferenceSchema;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:creator".
 */
export type CreatorEntityReferenceSchema = CreatorEntityReferenceSchema1 & CreatorEntityReferenceSchema2;
export type CreatorEntityReferenceSchema1 = EntityReferenceSchema;
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:owner".
 */
export type EntityOwnerReferenceSchema = EntityOwnerReferenceSchema1 & EntityOwnerReferenceSchema2;
export type EntityOwnerReferenceSchema1 = EntityReferenceSchema;
export interface GlobalSchema {
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "element".
 */
export interface ElementSchema {
    /**
     * Element symbol.
     */
    symbol?: string;
    /**
     * list of elemental properties
     */
    properties?: (AtomicRadius | Electronegativity | IonizationPotential)[];
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:primitive:scalar".
 */
export interface ScalarSchema {
    value: number;
}
export interface AtomicRadius2 {
    name?: "atomic_radius";
    units?: "km" | "m" | "pm" | "nm" | "angstrom" | "a.u." | "bohr" | "fractional" | "crystal" | "cartesian" | "alat";
}
export interface Electronegativity2 {
    name?: "electronegativity";
}
export interface IonizationPotential2 {
    name?: "ionization_potential";
    units?: "kJ/mol" | "eV" | "J/mol" | "hartree" | "cm-1" | "rydberg" | "eV/atom";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:schema-version".
 */
export interface SchemaVersion {
    /**
     * entity's schema version. Used to distinct between different schemas.
     */
    schemaVersion?: string;
}
export interface BaseInMemoryEntitySchema2 {
    /**
     * entity identity
     */
    _id?: string;
    /**
     * entity slug
     */
    slug?: string;
    systemName?: string;
    consistencyChecks?: ConsistencyCheck[];
}
/**
 * The output of consistency checks performed on data adhering to JSON schema, but inconsistent with scientific or logical rules, to show problems in UI.
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:consistency-check".
 */
export interface ConsistencyCheck {
    /**
     * Key of the property of the entity on which the consistency check is performed in Mongo dot notation, e.g. 'basis.coordinates.1'
     */
    key: string;
    /**
     * Name of the consistency check that is performed, which is listed in an enum.
     */
    name: "default" | "atomsTooClose" | "atomsOverlap";
    /**
     * Severity level of the problem, which is used in UI to differentiate.
     */
    severity: "info" | "warning" | "error";
    /**
     * Message generated by the consistency check describing the problem.
     */
    message: string;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:name".
 */
export interface NameEntitySchema {
    /**
     * entity name
     */
    name?: string;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:defaultable".
 */
export interface DefaultableEntitySchema {
    /**
     * Identifies that entity is defaultable
     */
    isDefault?: boolean;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:metadata".
 */
export interface MetadataSchema {
    metadata?: {};
}
export interface BaseJobSchema2 {
    /**
     * Identity used to track jobs originated from command-line
     */
    rmsId?: string;
    /**
     * job status
     */
    status: "pre-submission" | "queued" | "submitted" | "active" | "finished" | "terminate-queued" | "terminated" | "error" | "deleted" | "timeout";
    /**
     * Approximate start time of the job. e.g. within 10 min
     */
    startTime?: string;
    /**
     * The path to the working directory of this job, when the job originates from command-line
     */
    workDir?: string;
    compute: ComputeArgumentsSchema;
    _project: EntityReferenceSchema;
    _material?: EntityReferenceSchema;
    parent?: EntityReferenceSchema;
    /**
     * Context variables that the job will have access to at runtime
     */
    runtimeContext?: {};
    /**
     * history of the workflow scope on each update
     */
    scopeTrack?: {
        repetition?: number;
        scope?: WorkflowScopeSchema;
    }[];
}
/**
 * Custom keywords prefixed with validate correspond to custom validation methods implemented downstream
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "job:compute".
 */
export interface ComputeArgumentsSchema {
    /**
     * Name of the submission queues: https://docs.mat3ra.com/infrastructure/resource/queues/. Below enums are for Azure, then AWS circa 2022-08, hence the duplication.
     */
    queue: "D" | "OR" | "OF" | "OFplus" | "SR" | "SF" | "SFplus" | "GPOF" | "GP2OF" | "GP4OF" | "GPSF" | "GP2SF" | "GP4SF" | "OR4" | "OR8" | "OR16" | "SR4" | "SR8" | "SR16" | "GOF" | "G4OF" | "G8OF" | "GSF" | "G4SF" | "G8SF";
    /**
     * number of nodes used for the job inside the RMS.
     */
    nodes: number;
    /**
     * number of CPUs used for the job inside the RMS.
     */
    ppn: number;
    /**
     * Wallclock time limit for computing a job. Clock format: 'hh:mm:ss'
     */
    timeLimit: string;
    /**
     * Convention to use when reasoning about time limits
     */
    timeLimitType?: "per single attempt" | "compound";
    /**
     * Job is allowed to restart on termination.
     */
    isRestartable?: boolean;
    /**
     * Email notification for the job: n - never, a - job aborted, b - job begins, e - job ends. Last three could be combined.
     */
    notify?: string;
    /**
     * Email address to notify about job execution.
     */
    email?: string;
    /**
     * Maximum CPU count per node. This parameter is used to let backend job submission infrastructure know that this job is to be charged for the maximum CPU per node instead of the actual ppn. For premium/fast queues where resources are provisioned on-demand and exclusively per user.
     */
    maxCPU?: number;
    /**
     * Optional arguments specific to using application - VASP, Quantum Espresso, etc. Specified elsewhere
     */
    arguments?: QuantumEspressoArgumentsSchema;
    /**
     * Cluster where the job is executed. Optional on create. Required on job submission.
     */
    cluster?: {
        /**
         * FQDN of the cluster. e.g. master-1-staging.exabyte.io
         */
        fqdn?: string;
        /**
         * Job's identity in RMS. e.g. 1234.master-1-staging.exabyte.io
         */
        jid?: string;
    };
    /**
     * Computation error. Optional. Appears only if something happens on jobs execution.
     */
    errors?: {
        /**
         * Domain of the error appearance (internal).
         */
        domain?: "rupy" | "alfred" | "celim" | "webapp";
        /**
         * Should be a short, unique, machine-readable error code string. e.g. FileNotFound
         */
        reason?: string;
        /**
         * Human-readable error message. e.g. 'File Not Found: /home/demo/data/project1/job-123/job-config.json'
         */
        message?: string;
        /**
         * Full machine-readable error traceback. e.g. FileNotFound
         */
        traceback?: string;
    }[];
    /**
     * A Python compatible regex to exclude files from upload. e.g. ^.*.txt& excludes all files with .txt suffix
     */
    excludeFilesPattern?: string;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:modeling:espresso:arguments".
 */
export interface QuantumEspressoArgumentsSchema {
    /**
     * Processors can be divided into different `images`, each corresponding to a different self-consistent or linear-response calculation, loosely coupled to others.
     */
    nimage?: number;
    /**
     * Each image can be subpartitioned into `pools`, each taking care of a group of k-points.
     */
    npools?: number;
    /**
     * Each pool is subpartitioned into `band groups`, each taking care of a group of Kohn-Sham orbitals (also called bands, or wavefunctions).
     */
    nband?: number;
    /**
     * In order to allow good parallelization of the 3D FFT when the number of processors exceeds the number of FFT planes, FFTs on Kohn-Sham states are redistributed to `task` groups so that each group can process several wavefunctions at the same time.
     */
    ntg?: number;
    /**
     * A further level of parallelization, independent on PW or k-point parallelization, is the parallelization of subspace diagonalization / iterative orthonormalization. Both operations required the diagonalization of arrays whose dimension is the number of Kohn-Sham states (or a small multiple of it). All such arrays are distributed block-like across the `linear-algebra group`, a subgroup of the pool of processors, organized in a square 2D grid. As a consequence the number of processors in the linear-algebra group is given by n2, where n is an integer; n2 must be smaller than the number of processors in the PW group. The diagonalization is then performed in parallel using standard linear algebra operations.
     */
    ndiag?: number;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:entity-reference".
 */
export interface EntityReferenceSchema {
    /**
     * entity identity
     */
    _id?: string;
    /**
     * entity class
     */
    cls?: string;
    /**
     * entity slug
     */
    slug?: string;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:scope".
 */
export interface WorkflowScopeSchema {
    global: {
        [k: string]: unknown;
    };
    local: {
        [k: string]: unknown;
    };
}
export interface JobSchema2 {
    workflow: WorkflowSchema;
}
export interface BaseWorkflowSchema2 {
    /**
     * Array of characteristic properties calculated by this workflow (TODO: add enums)
     */
    properties?: (string | {})[];
    /**
     * Whether to use the dataset tab in the job designer. Mutually exclusive with using the materials tab.
     */
    isUsingDataset?: boolean;
    /**
     * Array of workflows with the same schema as the current one.
     */
    workflows?: {}[];
}
export interface WorkflowSchema2 {
    /**
     * Array of subworkflows. Subworkflow can be an instance of workflow to allow for nesting
     */
    subworkflows: Subworkflow[];
    /**
     * Contains the Units of the Workflow
     */
    units: (WorkflowUnitSchema1 | DataIOUnitSchema | MapUnitSchema | ReduceUnitSchema | ConditionUnitSchema | AssertionUnitSchema | ExecutionUnitSchemaBase | AssignmentUnitSchema | ProcessingUnitSchema)[];
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:base-flow".
 */
export interface BaseFlow {
    /**
     * subworkflow identity
     */
    _id?: string;
    /**
     * Human-readable name of the subworkflow. e.g. Total-energy
     */
    name: string;
    /**
     * Array of characteristic properties calculated by this subworkflow
     */
    properties?: (string | {})[];
    compute?: ComputeArgumentsSchema;
}
export interface Subworkflow2 {
    /**
     * Contains the Units of the subworkflow
     */
    units?: WorkflowUnitSchema[];
    model: BaseModel;
    application: ApplicationSchemaBase;
    /**
     * Defines whether to store the results/properties extracted in this unit to properties collection
     */
    isDraft?: boolean;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit:runtime:runtime-items".
 */
export interface RuntimeItemsSchemaPrePostProcessorsMonitorsResults {
    /**
     * names of the pre-processors for this calculation
     */
    preProcessors?: RuntimeItemSchema[];
    /**
     * names of the post-processors for this calculation
     */
    postProcessors?: RuntimeItemSchema[];
    /**
     * names of the monitors for this calculation
     */
    monitors?: RuntimeItemSchema[];
    /**
     * names of the results for this calculation
     */
    results?: RuntimeItemSchema[];
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit:runtime:-runtime-item-name-object".
 */
export interface NameResultSchema {
    /**
     * The name of this item. e.g. scf_accuracy
     */
    name: string;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:tags".
 */
export interface EntityTagsSchema {
    /**
     * entity tags
     */
    tags?: string[];
}
export interface WorkflowUnitSchema2 {
    _id?: string;
    isDraft?: boolean;
    /**
     * type of the unit
     */
    type: string;
    /**
     * name of the unit. e.g. pw_scf
     */
    name?: string;
    /**
     * Status of the unit.
     */
    status?: "idle" | "active" | "warning" | "error" | "finished";
    /**
     * Whether this unit is the first one to be executed.
     */
    head?: boolean;
    /**
     * Identity of the unit in the workflow. Used to trace the execution flow of the workflow.
     */
    flowchartId: string;
    /**
     * Next unit's flowchartId. If empty, the current unit is the last.
     */
    next?: string;
    /**
     * Whether Rupy should attempt to use Jinja templating to add context variables into the unit
     */
    enableRender?: boolean;
    context?: {};
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "model".
 */
export interface BaseModel {
    /**
     * general type of the model, eg. `dft`
     */
    type: string;
    /**
     * general subtype of the model, eg. `lda`
     */
    subtype: string;
    method: BaseMethod;
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "method".
 */
export interface BaseMethod {
    /**
     * general type of this method, eg. `pseudopotential`
     */
    type: string;
    /**
     * general subtype of this method, eg. `ultra-soft`
     */
    subtype: string;
    /**
     * Object showing the actual possible precision based on theory and implementation
     */
    precision?: {};
    /**
     * additional data specific to method, eg. array of pseudopotentials
     */
    data?: {};
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software:application".
 */
export interface ApplicationSchemaBase {
    /**
     * The name of the application. e.g. espresso
     */
    name: string;
    /**
     * The short name of the application. e.g. qe
     */
    shortName?: string;
    /**
     * Application's short description.
     */
    summary?: string;
    /**
     * Application version. e.g. 5.3.5
     */
    version?: string;
    /**
     * Application build. e.g. VTST
     */
    build?: string;
    /**
     * Whether advanced compute options are present
     */
    hasAdvancedComputeOptions?: boolean;
    /**
     * Whether licensing is present
     */
    isLicensed?: boolean;
    [k: string]: unknown;
}
export interface DataIOUnitSchema2 {
    type?: "io";
    subtype: "input" | "output" | "dataFrame";
    source: "api" | "db" | "object_storage";
    input: (DataIORestAPIInputSchema | DataIODatabaseInputOutputSchema | ObjectStorageIoSchema)[];
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit:io:api".
 */
export interface DataIORestAPIInputSchema {
    /**
     * rest API endpoint
     */
    endpoint: string;
    /**
     * rest API endpoint options
     */
    endpoint_options: {};
    /**
     * the name of the variable in local scope to save the data under
     */
    name?: string;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit:io:object-storage".
 */
export interface ObjectStorageIoSchema {
    objectData: ObjectStorageContainerData;
    /**
     * if a file with the same filename already exists, whether to overwrite the old file
     */
    overwrite?: boolean;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reusable:object-storage-container-data".
 */
export interface ObjectStorageContainerData {
    /**
     * Object storage container for the file
     */
    CONTAINER: string;
    /**
     * Name of the file inside the object storage bucket
     */
    NAME: string;
    /**
     * Object storage provider
     */
    PROVIDER: string;
    /**
     * Region for the object container specified in Container
     */
    REGION: string;
    /**
     * Size of the file in bytes
     */
    SIZE?: number;
    /**
     * Unix timestamp showing when the file was last modified
     */
    TIMESTAMP?: string;
}
export interface MapUnitSchema2 {
    type?: "map";
    /**
     * Id of workflow to run inside map
     */
    workflowId: string;
    /**
     * Input information for map.
     */
    input: {
        /**
         * Name of the target variable to substitute using the values below. e.g. K_POINTS
         */
        target: string;
        /**
         * Scope to retrieve `values` from, global or flowchartId. Optional if `values` is given.
         */
        scope?: string;
        /**
         * Name of the variable inside the scope to retrieve `values` from. Optional if `values` is given.
         */
        name?: string;
        /**
         * Sequence of values for the target Jinja variable. Optional if `scope` and `name` are given. This can be used for map-reduce type parallel execution
         */
        values?: (string | number | {})[];
        useValues?: boolean;
    };
}
export interface ReduceUnitSchema2 {
    type?: "reduce";
    /**
     * corresponding map unit flowchart ID
     */
    mapFlowchartId: string;
    /**
     * input information for reduce unit
     */
    input: {
        /**
         * reduce operation, e.g. aggregate
         */
        operation: string;
        /**
         * arguments which are passed to reduce operation function
         */
        arguments: string[];
    }[];
}
export interface ConditionUnitSchema2 {
    type?: "condition";
    /**
     * Input information for condition.
     */
    input: WorkflowUnitInputSchema[];
    /**
     * Condition statement. e.g. 'abs(x-total_energy) < 1e-5'
     */
    statement: string;
    /**
     * Flowchart ID reference for `then` part of the condition.
     */
    then: string;
    /**
     * Flowchart ID reference for `else` part of the condition.
     */
    else: string;
    /**
     * Maximum occurrence of the condition, usable for loops.
     */
    maxOccurrences?: number;
    /**
     * Throw exception on reaching to maximum occurence.
     */
    throwException?: boolean;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit:input:-inputItemScope".
 */
export interface WorkflowUnitInputSchema {
    /**
     * Scope of the variable. e.g. 'global' or 'flowchart_id_2'
     */
    scope: string;
    /**
     * Name of the input data. e.g. total_energy
     */
    name: string;
}
export interface AssertionUnitSchema2 {
    type?: "assertion";
    statement: string;
    errorMessage?: string;
}
export interface ExecutionUnitSchemaBase2 {
    type?: "execution";
    application: ApplicationSchemaBase;
    executable?: ExecutableSchema;
    flavor?: FlavorSchema;
    /**
     * unit input (type to be specified by the application's execution unit)
     */
    input: {
        [k: string]: unknown;
    };
}
export interface ExecutableSchema2 {
    /**
     * The name of the executable. e.g. pw.x
     */
    name: string;
    /**
     * _ids of the application this executable belongs to
     */
    applicationId: string[];
    /**
     * Whether advanced compute options are present
     */
    hasAdvancedComputeOptions?: boolean;
}
export interface FlavorSchema2 {
    /**
     * The name of the executable flavor. e.g. `pw_scf`
     */
    name: string;
    /**
     * _id of the executable this flavor belongs to
     */
    executableId: string;
    /**
     * name of the executable this flavor belongs to
     */
    executableName?: string;
    /**
     * name of the application this flavor belongs to
     */
    applicationName?: string;
    input?: ExecutionUnitInputSchema;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit:input:-inputItemId".
 */
export interface ExecutionUnitInputIdItemSchemaForPhysicsBasedSimulationEngines {
    templateId: string;
    templateName?: string;
    /**
     * name of the resulting input file, if different than template name
     */
    name?: string;
}
export interface AssignmentUnitSchema2 {
    type?: "assignment";
    /**
     * Input information for assignment. if omitted, means that it is an initialization unit, otherwise it is an assignment.
     */
    input?: WorkflowUnitInputSchema[];
    /**
     * Name of the global variable. e.g. 'x'
     */
    operand?: string;
    /**
     * Value of the variable. The value content could be a simple integer, string or a python expression. e.g. '0' (initialization), 'sin(x)+1' (expression)
     */
    value: string;
}
export interface ProcessingUnitSchema2 {
    type?: "processing";
    /**
     * Contains information about the operation used.
     */
    operation: string;
    /**
     * Contains information about the specific type of the operation used.
     */
    operationType: string;
    /**
     * unit input (type to be specified by the child units)
     */
    inputData: {
        [k: string]: unknown;
    };
}
export interface MaterialSchema2 {
    /**
     * reduced chemical formula
     */
    formula?: string;
    /**
     * chemical formula based on the number of atoms of each element in the supercell
     */
    unitCellFormula?: string;
    basis: BasisSchema;
    lattice: LatticeSchema;
    derivedProperties?: DerivedPropertiesSchema;
    external?: DatabaseSourceSchema;
    src?: FileSourceSchema;
    /**
     * Hash string for a scaled structure with lattice vector a set to 1 (eg. for materials under pressure).
     */
    scaledHash?: string;
    /**
     * Corresponding ICSD id of the material
     */
    icsdId?: number;
    /**
     * Whether to work in the finite molecular picture (usually with atomic orbital basis)
     */
    isNonPeriodic?: boolean;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:basis".
 */
export interface BasisSchema {
    elements: AtomicElements[];
    coordinates: AtomicCoordinate[];
    name?: string;
    units?: string;
    bonds?: BondsSchema;
}
/**
 * elements of atoms by ids, string, unitless
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:basis:atomic-element".
 */
export interface AtomicElements {
    id: number;
    value: string;
    /**
     * Occurrence is for fractional occupations
     */
    occurrence?: number;
    oxidationState?: number;
}
/**
 * coordinates of atoms by ids, vector, unitless
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:basis:atomic-coordinate".
 */
export interface AtomicCoordinate {
    id?: number;
    value?: VectorSchema;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:abstract::d-vector-basis".
 */
export interface DimensionalVectorBasis {
    a: ArrayOf3NumberElementsSchema;
    b: ArrayOf3NumberElementsSchema;
    c: ArrayOf3NumberElementsSchema;
}
export interface LatticeExplicitUnit2 {
    /**
     * lattice parameter for fractional coordinates
     */
    alat?: number;
    units?: "km" | "m" | "pm" | "nm" | "angstrom" | "a.u." | "bohr" | "fractional" | "crystal" | "cartesian" | "alat";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:primitive::d-lattice".
 */
export interface DimensionalLatticeSchema {
    /**
     * length of the first lattice vector
     */
    a: number;
    /**
     * length of the second lattice vector
     */
    b: number;
    /**
     * length of the third lattice vector
     */
    c: number;
    /**
     * angle between first and second lattice vector
     */
    alpha: number;
    /**
     * angle between second and third lattice vector
     */
    beta: number;
    /**
     * angle between first and third lattice vector
     */
    gamma: number;
}
export interface LatticeImplicitSchema2 {
    type: LatticeTypeSchema;
    units?: {
        length?: "angstrom" | "bohr";
        angle?: "degree" | "radian";
    };
}
export interface LatticeSchema2 {
    name?: "lattice";
}
export interface VolumeSchema2 {
    name?: "volume";
    units?: "angstrom^3";
}
export interface DensitySchema2 {
    name?: "density";
    units?: "g/cm^3";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:symmetry".
 */
export interface SymmetrySchema {
    /**
     * point group symbol in Schoenflies notation
     */
    pointGroupSymbol?: string;
    /**
     * space group symbol in Hermann–Mauguin notation
     */
    spaceGroupSymbol?: string;
    /**
     * tolerance used for symmetry calculation
     */
    tolerance?: ScalarSchema;
    name?: "symmetry";
}
export interface ElementalRatio2 {
    name?: "elemental_ratio";
    value?: number;
    /**
     * the element this ratio is for
     */
    element?: string;
}
export interface PNorm2 {
    name?: "p-norm";
    /**
     * degree of the dimensionality of the norm
     */
    degree?: number;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:primitive:string".
 */
export interface PrimitiveString {
    value: string;
}
export interface InChIRepresentationSchema2 {
    name?: "inchi";
}
export interface InChIKeyRepresentationSchema2 {
    name?: "inchi_key";
}
/**
 * information about a database source
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:database-source".
 */
export interface DatabaseSourceSchema {
    /**
     * ID string for the materials uploaded from a third party source inside the third party source. For materialsproject.org an example ID is mp-32
     */
    id: string;
    /**
     * Third party source name, e.g. materials project, 2dmatpedia, ICSD, etc.
     */
    source: string;
    /**
     * A flag that is true when material is initially imported from a third party * (as opposed to being independently designed from scratch).
     */
    origin: boolean;
    /**
     * Original response from external source.
     */
    data?: {};
    /**
     * Digital Object Identifier, e.g. 10.1088/0953-8984/25/10/105506
     */
    doi?: string;
    /**
     * The URL of the original record, e.g. https://next-gen.materialsproject.org/materials/mp-48
     */
    url?: string;
}
/**
 * file source with the information inside
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:file-source".
 */
export interface FileSourceSchema {
    /**
     * file extension
     */
    extension?: string;
    /**
     * file name without extension
     */
    filename: string;
    /**
     * file content as raw text
     */
    text: string;
    /**
     * MD5 hash based on file content
     */
    hash: string;
}
export interface ProjectSchema2 {
    /**
     * project GID
     */
    gid?: number;
    /**
     * charge rates info for project
     */
    clusterBasedChargeRates?: {
        rate?: number;
        timestamp?: number;
        hostname?: string;
    }[];
    isExternal?: boolean;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` ":pse:file:applications:espresso:::::pw:x".
 */
export interface PwxMainSchema {
    "&CONTROL"?: ControlSchema;
    "&SYSTEM"?: SystemSchema;
    "&ELECTRONS"?: ElectronsSchema;
    "&IONS"?: IonsSchema | null;
    "&CELL"?: CellSchema | null;
    ATOMIC_SPECIES?: AtomicSpeciesSchema;
    ATOMIC_POSITIONS?: AtomicPositionsSchema;
    K_POINTS?: KPointsSchema;
    CELL_PARAMETERS?: CellParametersSchema;
    HUBBARD?: HubbardSchema;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` ":pse:file:applications:espresso:::::pw:x:control".
 */
export interface ControlSchema {
    /**
     * A string describing the task to be performed
     */
    calculation?: "scf" | "nscf" | "bands" | "relax" | "md" | "vc-relax" | "vc-md";
    /**
     * reprinted on output.
     */
    title?: string;
    /**
     * Currently two verbosity levels are implemented: high, low. 'debug' and 'medium' have the same effect as 'high'; 'default' and 'minimal' as 'low'
     */
    verbosity?: "high" | "low" | "debug" | "medium" | "minimal" | "default";
    restart_mode?: "from_scratch" | "restart";
    /**
     * OBSOLETE - NO LONGER IMPLEMENTED
     */
    wf_collect?: boolean;
    /**
     * Default: 1 if calculation == 'scf', 'nscf', 'bands'; 50 for the other cases; Number of molecular-dynamics or structural optimization steps performed in this run. If set to 0, the code performs a quick "dry run", stopping just after initialization. This is useful to check for input correctness and to have the summary printed. NOTE: in MD calculations, the code will perform "nstep" steps even if restarting from a previously interrupted calculation.
     */
    nstep?: number;
    /**
     * band energies are written every iprint iterations
     */
    iprint?: number;
    /**
     * calculate stress. It is set to .TRUE. automatically if calculation == 'vc-md' or 'vc-relax'
     */
    tstress?: boolean;
    /**
     * calculate forces. It is set to .TRUE. automatically if calculation == 'relax','md','vc-md'
     */
    tprnfor?: boolean;
    /**
     * time step for molecular dynamics, in Rydberg atomic units (1 a.u.=4.8378 * 10^-17 s : beware, the CP code uses Hartree atomic units, half that much!!!)
     */
    dt?: number;
    /**
     * input, temporary, output files are found in this directory, see also wfcdir
     */
    outdir?: string;
    /**
     * This directory specifies where to store files generated by each processor (*.wfc{N}, *.igk{N}, etc.). Useful for machines without a parallel file system: set wfcdir to a local file system, while outdir should be a parallel or network file system, visible to all processors. Beware: in order to restart from interrupted runs, or to perform further calculations using the produced data files, you may need to copy files to outdir. Works only for pw.x.
     */
    wfcdir?: string;
    /**
     * prepended to input/output filenames: prefix.wfc, prefix.rho, etc.
     */
    prefix?: string;
    /**
     * OBSOLETE - NO LONGER IMPLEMENTED
     */
    lkpoint_dir?: boolean;
    /**
     * Jobs stops after max_seconds CPU time. Use this option in conjunction with option restart_mode if you need to split a job too long to complete into shorter jobs that fit into your batch queues.
     */
    max_seconds?: number;
    /**
     * Convergence threshold on total energy (a.u) for ionic minimization: the convergence criterion is satisfied when the total energy changes less than etot_conv_thr between two consecutive scf steps. Note that etot_conv_thr is extensive, like the total energy. See also forc_conv_thr - both criteria must be satisfied
     */
    etot_conv_thr?: number;
    /**
     * Convergence threshold on forces (a.u) for ionic minimization: the convergence criterion is satisfied when all components of all forces are smaller than forc_conv_thr. See also etot_conv_thr - both criteria must be satisfied
     */
    forc_conv_thr?: number;
    /**
     * Specifies the amount of disk I/O activity: (only for binary files and xml data file in data directory; other files printed at each molecular dynamics / structural optimization step are not controlled by this option )
     */
    disk_io?: "high" | "medium" | "low" | "nowf" | "none";
    /**
     * directory containing pseudopotential files. Default: value of the $ESPRESSO_PSEUDO environment variable if set; '$HOME/espresso/pseudo/' otherwise
     */
    pseudo_dir?: string;
    /**
     * If .TRUE. a saw-like potential simulating an electric field is added to the bare ionic potential. See variables edir, eamp, emaxpos, eopreg for the form and size of the added potential.
     */
    tefield?: boolean;
    /**
     * If .TRUE. and tefield==.TRUE. a dipole correction is also added to the bare ionic potential - implements the recipe of L. Bengtsson, PRB 59, 12301 (1999). See variables edir, emaxpos, eopreg for the form of the correction. Must be used ONLY in a slab geometry, for surface calculations, with the discontinuity FALLING IN THE EMPTY SPACE.
     */
    dipfield?: boolean;
    /**
     * If .TRUE. a homogeneous finite electric field described through the modern theory of the polarization is applied. This is different from tefield == .true. !
     */
    lelfield?: boolean;
    /**
     * In the case of a finite electric field  ( lelfield == .TRUE. ) it defines the number of iterations for converging the wavefunctions in the electric field Hamiltonian, for each external iteration on the charge density
     */
    nberrycyc?: number;
    /**
     * If .TRUE. perform orbital magnetization calculation.
     */
    lorbm?: boolean;
    /**
     * If .TRUE. perform a Berry phase calculation. See the header of PW/src/bp_c_phase.f90 for documentation
     */
    lberry?: boolean;
    /**
     * For Berry phase calculation: direction of the k-point strings in reciprocal space. Allowed values: 1, 2, 3 1=first, 2=second, 3=third reciprocal lattice vector For calculations with finite electric fields (lelfield==.true.) "gdir" is the direction of the field.
     */
    gdir?: number;
    /**
     * For Berry phase calculation: number of k-points to be calculated along each symmetry-reduced string. The same for calculation with finite electric fields (lelfield==.true.).
     */
    nppstr?: number;
    /**
     * In the case of charged cells (tot_charge .ne. 0) setting gate = .TRUE. represents the counter charge (i.e. -tot_charge) not by a homogeneous background charge but with a charged plate, which is placed at zgate (see below). Details of the gate potential can be found in T. Brumme, M. Calandra, F. Mauri; PRB 89, 245406 (2014). Note, that in systems which are not symmetric with respect to the plate, one needs to enable the dipole correction! (dipfield=.true.). Currently, symmetry can be used with gate=.true. but carefully check that no symmetry is included which maps z to -z even if in principle one could still use them for symmetric systems (i.e. no dipole correction). For nosym=.false. verbosity is set to 'high'. Note: this option was called "monopole" in v6.0 and 6.1 of pw.x
     */
    gate?: boolean;
    /**
     * IF .TRUE. , a two chemical potential calculation for the simulation of photoexcited systems is performed, constraining a fraction of the electrons in the conduction manifold.
     */
    twochem?: boolean;
    /**
     * If .TRUE. perform a constant bias potential (constant-mu) calculation for a system with ESM method. See the header of PW/src/fcp_module.f90 for documentation. To perform the calculation, you must set a namelist FCP.
     */
    lfcp?: boolean;
    /**
     * If .TRUE. perform a 3D-RISM-SCF calculation [for details see H.Sato et al., JCP 112, 9463 (2000), doi:10.1063/1.481564]. The solvent's distributions are calculated by 3D-RISM, though solute is treated as SCF. The charge density and the atomic positions are optimized, simultaneously with the solvents. To perform the calculation, you must set a namelist RISM and a card SOLVENTS. If assume_isolated = 'esm' and esm_bc = 'bc1', Laue-RISM is calculated instead of 3D-RISM and coupled with ESM method (i.e. ESM-RISM). [for details see S.Nishihara and M.Otani, PRB 96, 115429 (2017)]. The default of mixing_beta is 0.2 for both 3D-RISM and Laue-RISM. For structural relaxation with BFGS, ignore_wolfe is always .TRUE. .
     */
    trism?: boolean;
}
export interface SystemSchema2 {
    ibrav: number;
    /**
     * number of atoms in the unit cell (ALL atoms, except if space_group is set, in which case, INEQUIVALENT atoms)
     */
    nat: number;
    /**
     * number of types of atoms in the unit cell
     */
    ntyp: number;
    /**
     * Default: for an insulator, nbnd = number of valence bands (nbnd = # of electrons /2); for a metal, 20% more (minimum 4 more)
     */
    nbnd?: number;
    /**
     * Default: nbnd_cond = nbnd - # of electrons / 2 in the collinear case; nbnd_cond = nbnd - # of electrons in the noncollinear case.
     */
    nbnd_cond?: number;
    tot_charge?: number;
    /**
     * starting charge on atomic type 'i', to create starting potential with startingpot = 'atomic'.
     */
    starting_charge?: number;
    /**
     * Total majority spin charge - minority spin charge. Used to impose a specific total electronic magnetization. If unspecified then tot_magnetization variable is ignored and the amount of electronic magnetization is determined during the self-consistent cycle.
     */
    tot_magnetization?: number;
    starting_magnetization?: number[];
    /**
     * kinetic energy cutoff (Ry) for wavefunctions
     */
    ecutwfc: number;
    /**
     * Kinetic energy cutoff (Ry) for charge density and potential For norm-conserving pseudopotential you should stick to the default value, you can reduce it by a little but it will introduce noise especially on forces and stress. Default: 4 * ecutwfc
     */
    ecutrho?: number;
    /**
     * Kinetic energy cutoff (Ry) for the exact exchange operator in EXX type calculations. By default this is the same as ecutrho but in some EXX calculations, a significant speed-up can be obtained by reducing ecutfock, at the expense of some loss in accuracy. Must be .gt. ecutwfc. Not implemented for stress calculation and for US-PP and PAW pseudopotentials.
     */
    ecutfock?: number;
    /**
     * Three-dimensional FFT mesh (hard grid) for charge density (and scf potential). If not specified the grid is calculated based on the cutoff for charge density (see also ecutrho)
     */
    nr1?: number;
    /**
     * Three-dimensional FFT mesh (hard grid) for charge density (and scf potential). If not specified the grid is calculated based on the cutoff for charge density (see also ecutrho)
     */
    nr2?: number;
    /**
     * Three-dimensional FFT mesh (hard grid) for charge density (and scf potential). If not specified the grid is calculated based on the cutoff for charge density (see also ecutrho)
     */
    nr3?: number;
    /**
     * Three-dimensional mesh for wavefunction FFT and for the smooth part of charge density ( smooth grid ). Coincides with nr1, nr2, nr3 if ecutrho = 4 * ecutwfc ( default )
     */
    nr1s?: number;
    /**
     * Three-dimensional mesh for wavefunction FFT and for the smooth part of charge density ( smooth grid ). Coincides with nr1, nr2, nr3 if ecutrho = 4 * ecutwfc ( default )
     */
    nr2s?: number;
    /**
     * Three-dimensional mesh for wavefunction FFT and for the smooth part of charge density ( smooth grid ). Coincides with nr1, nr2, nr3 if ecutrho = 4 * ecutwfc ( default )
     */
    nr3s?: number;
    nosym?: boolean;
    nosym_evc?: boolean;
    /**
     * if (.TRUE.) disable the usage of k => -k symmetry (time reversal) in k-point generation
     */
    noinv?: boolean;
    /**
     * if (.TRUE.) disable the usage of magnetic symmetry operations that consist in a rotation + time reversal.
     */
    no_t_rev?: boolean;
    /**
     * if (.TRUE.) force the symmetry group to be symmorphic by disabling symmetry operations having an associated fractionary translation
     */
    force_symmorphic?: boolean;
    use_all_frac?: boolean;
    occupations?: "smearing" | "tetrahedra" | "tetrahedra_lin" | "tetrahedra_opt" | "fixed" | "from_input";
    one_atom_occupations?: boolean;
    starting_spin_angle?: boolean;
    /**
     * value of the gaussian spreading (Ry) for brillouin-zone integration in the conduction manifold in a two-chemical potential calculation (twochem=.true.).
     */
    degauss_cond?: number;
    /**
     * Number of electrons placed in the conduction manifold in a two-chemical potential calculation (twochem=.true.). Of the total # of electrons nelec, nelec-nelec_cond will occupy the valence manifold and nelec_cond will be constrained in the conduction manifold.
     */
    nelec_cond?: number;
    /**
     * value of the gaussian spreading (Ry) for brillouin-zone integration in metals.
     */
    degauss?: number;
    smearing?: "gaussian" | "gauss" | "methfessel-paxton" | "m-p" | "mp" | "marzari-vanderbilt" | "cold" | "m-v" | "mv" | "fermi-dirac" | "f-d" | "fd";
    nspin?: number;
    /**
     * Strength of the gammaDFT potential.
     */
    sic_gamma?: number;
    /**
     * Type of polaron in gammaDFT.
     */
    pol_type?: "e" | "h";
    /**
     * Enable the calculation of the total energy in gammaDFT. When .true., a preliminary calculation is performed to calculate the electron density in the absence of the polaron. When .false., the total energy printed in output should not be considered. For structural relaxations, it is recommended to use .false. to avoid doubling the computational cost.
     */
    sic_energy?: boolean;
    /**
     * Valence band shift (in eV) through self-consistent scissor operator. When performing gammaDFT calculations of polarons, the polaron level is not shifted.
     */
    sci_vb?: number;
    /**
     * Conduction band band shift (in eV) through self-consistent scissor operator. When performing gammaDFT calculations of polarons, the polaron level is not shifted.
     */
    sci_cb?: number;
    /**
     * if .true. the program will perform a noncollinear calculation.
     */
    noncolin?: boolean;
    ecfixed?: number;
    qcutz?: number;
    q2sigma?: number;
    /**
     * Exchange-correlation functional: eg 'PBE', 'BLYP' etc See Modules/funct.f90 for allowed values. Overrides the value read from pseudopotential files. Use with care and if you know what you are doing!
     */
    input_dft?: string;
    /**
     * Use Adaptively Compressed Exchange operator as in Lin Lin, J. Chem. Theory Comput. 2016, 12, 2242--2249, doi:10.1021/acs.jctc.6b00092
     */
    ace?: boolean;
    /**
     * Fraction of EXX for hybrid functional calculations. In the case of input_dft='PBE0', the default value is 0.25, while for input_dft='B3LYP' the exx_fraction default value is 0.20.
     */
    exx_fraction?: number;
    /**
     * screening_parameter for HSE like hybrid functionals.
     */
    screening_parameter?: number;
    exxdiv_treatment?: "gygi-baldereschi" | "vcut_spherical" | "vcut_ws" | "none";
    /**
     * Specific for EXX. If .true., extrapolate the G=0 term of the potential
     */
    x_gamma_extrapolation?: boolean;
    /**
     * Reciprocal space cutoff for correcting Coulomb potential divergencies at small q vectors.
     */
    ecutvcut?: number;
    /**
     * Three-dimensional mesh for q (k1-k2) sampling of the Fock operator (EXX). Can be smaller than the number of k-points.
     */
    nqx1?: number;
    /**
     * Three-dimensional mesh for q (k1-k2) sampling of the Fock operator (EXX). Can be smaller than the number of k-points.
     */
    nqx2?: number;
    /**
     * Three-dimensional mesh for q (k1-k2) sampling of the Fock operator (EXX). Can be smaller than the number of k-points.
     */
    nqx3?: number;
    /**
     * Overlap threshold over which the exchange integral over a pair of localized orbitals is included in the evaluation of EXX operator. Any value greater than 0.0 triggers the SCDM localization and the evaluation on EXX using the localized orbitals. Very small value of the threshold should yield the same result as the default EXX evaluation
     */
    localization_thr?: number;
    Hubbard_occ?: [] | [number] | [number, number] | [number, number, number][];
    Hubbard_alpha?: number[];
    Hubbard_beta?: number[];
    starting_ns_eigenvalue?: number[][][];
    /**
     * If true, nscf calculation will exit in restart mode, scf calculation will restart from there if DMFT updates are provided as hdf5 archive. Scf calculation should be used only with electron_maxstep = 1.
     */
    dmft?: boolean;
    /**
     * prepended to hdf5 archive: dmft_prefix.h5
     */
    dmft_prefix?: string;
    /**
     * If ensemble_energies = .true., an ensemble of xc energies is calculated non-selfconsistently for perturbed exchange-enhancement factors and LDA vs. PBE correlation ratios after each converged electronic ground state calculation.
     */
    ensemble_energies?: boolean;
    /**
     * The direction of the electric field or dipole correction is parallel to the bg(:,edir) reciprocal lattice vector, so the potential is constant in planes defined by FFT grid points; edir = 1, 2 or 3. Used only if tefield is .TRUE.
     */
    edir?: number;
    /**
     * Position of the maximum of the saw-like potential along crystal axis edir, within the  unit cell (see below), 0 < emaxpos < 1 Used only if tefield is .TRUE.
     */
    emaxpos?: number;
    /**
     * Zone in the unit cell where the saw-like potential decreases. ( see below, 0 < eopreg < 1 ). Used only if tefield is .TRUE.
     */
    eopreg?: number;
    eamp?: number;
    /**
     * The angle expressed in degrees between the initial magnetization and the z-axis. For noncollinear calculations only; index i runs over the atom types.
     *
     * @minItems 1
     * @maxItems 1
     */
    angle1?: [number];
    /**
     * The angle expressed in degrees between the projection of the initial magnetization on x-y plane and the x-axis. For noncollinear calculations only.
     *
     * @minItems 1
     * @maxItems 1
     */
    angle2?: [number];
    /**
     * When starting a non collinear calculation using an existing density file from a collinear lsda calculation assumes previous density points in z direction and rotates it in the direction described by angle1 and angle2 variables for atomic type 1
     */
    lforcet?: boolean;
    /**
     * Used to perform constrained calculations in magnetic systems.
     */
    constrained_magnetization?: "none" | "total" | "atomic" | "total direction" | "atomic direction";
    /**
     * @minItems 3
     * @maxItems 3
     */
    fixed_magnetization?: [number, number, number];
    /**
     * parameter used for constrained_magnetization calculations N.B.: if the scf calculation does not converge, try to reduce lambda to obtain convergence, then restart the run with a larger lambda
     */
    lambda?: number;
    /**
     * determines when atomic magnetic moments are printed on output
     */
    report?: number;
    /**
     * if .TRUE. the noncollinear code can use a pseudopotential with spin-orbit.
     */
    lspinorb?: boolean;
    assume_isolated?: "none" | "makov-payne" | "m-p" | "mp" | "martyna-tuckerman" | "m-t" | "mt" | "esm" | "2D";
    esm_bc?: "pbc" | "bc1" | "bc2" | "bc3";
    /**
     * If assume_isolated = 'esm', determines the position offset [in a.u.] of the start of the effective screening region, measured relative to the cell edge. (ESM region begins at z = +/- [L_z/2 + esm_w] ).
     */
    esm_w?: number;
    /**
     * If assume_isolated = 'esm' and esm_bc = 'bc2', gives the magnitude of the electric field [Ry/a.u.] to be applied between semi-infinite ESM electrodes.
     */
    esm_efield?: number;
    /**
     * If assume_isolated = 'esm', gives the number of z-grid points for the polynomial fit along the cell edge.
     */
    esm_nfit?: number;
    /**
     * If .TRUE. perform a constant bias potential (constant-mu) calculation with Grand-Canonical SCF.
     */
    lgcscf?: boolean;
    /**
     * The target Fermi energy (eV) of GC-SCF. One can start with appropriate total charge of the system by giving tot_charge
     */
    gcscf_mu?: number;
    /**
     * Convergence threshold of Fermi energy (eV) for GC-SCF.
     */
    gcscf_conv_thr?: number;
    /**
     * Mixing factor for GC-SCF. Larger values are recommended, if systems with small DOS on Fermi surface as graphite.
     */
    gcscf_beta?: number;
    /**
     * Type of Van der Waals correction
     */
    vdw_corr?: "grimme-d2" | "Grimme-D2" | "DFT-D" | "dft-d" | "grimme-d3" | "Grimme-D3" | "DFT-D3" | "dft-d3" | "TS" | "ts" | "ts-vdw" | "ts-vdW" | "tkatchenko-scheffler" | "MBD" | "mbd" | "many-body-dispersion" | "mbd_vdw" | "XDM" | "xdm";
    /**
     * OBSOLESCENT, same as vdw_corr='DFT-D'
     */
    london?: boolean;
    /**
     * global scaling parameter for DFT-D. Default is good for PBE.
     */
    london_s6?: number;
    /**
     * atomic C6 coefficient of each atom type
     */
    london_c6?: number;
    /**
     * atomic vdw radii of each atom type
     */
    london_rvdw?: number;
    /**
     * cutoff radius (a.u.) for dispersion interactions
     */
    london_rcut?: number;
    /**
     * Version of Grimme implementation of Grimme-D3
     */
    dftd3_version?: number;
    /**
     * Turn three-body terms in Grimme-D3 on. If .false. two-body contributions only are computed, using two-body parameters of Grimme-D3. If dftd3_version=2, three-body contribution is always disabled.
     */
    dftd3_threebody?: boolean;
    /**
     * Optional: controls the convergence of the vdW energy (and forces). The default value is a safe choice, likely too safe, but you do not gain much in increasing it
     */
    ts_vdw_econv_thr?: number;
    /**
     * Optional: set it to .TRUE. when computing the Tkatchenko-Scheffler vdW energy or the Many-Body dispersion (MBD) energy for an isolated (non-periodic) system.
     */
    ts_vdw_isolated?: boolean;
    /**
     * OBSOLESCENT, same as vdw_corr='xdm'
     */
    xdm?: boolean;
    /**
     * Damping function parameter a1 (adimensional)
     */
    xdm_a1?: number;
    /**
     * Damping function parameter a2 (angstrom)
     */
    xdm_a2?: number;
    /**
     * The number of the space group of the crystal, as given in the International Tables of Crystallography A (ITA)
     */
    space_group?: number;
    /**
     * Used only for monoclinic lattices
     */
    uniqueb?: boolean;
    /**
     * Used only for space groups that in the ITA allow the use of two different origins
     */
    origin_choice?: number;
    /**
     * Used only for rhombohedral space groups.
     */
    rhombohedral?: boolean;
    /**
     * used only if gate = .TRUE.
     */
    zgate?: number;
    /**
     * used only if gate = .TRUE.
     */
    relaxz?: boolean;
    /**
     * used only if gate = .TRUE.
     */
    block?: boolean;
    /**
     * used only if gate = .TRUE. and block = .TRUE.
     */
    block_1?: number;
    /**
     * used only if gate = .TRUE. and block = .TRUE.
     */
    block_2?: number;
    /**
     * used only if gate = .TRUE. and block = .TRUE.
     */
    block_height?: number;
    /**
     * Number of activated external ionic force fields.
     */
    nextffield?: number;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` ":pse:file:applications:espresso:::::pw:x:electrons".
 */
export interface ElectronsSchema {
    /**
     * maximum number of iterations in a scf step. If exact exchange is active, this will affect the inner loops.
     */
    electron_maxstep?: number;
    /**
     * maximum number of outer iterations in a scf calculation with exact exchange.
     */
    exx_maxstep?: number;
    /**
     * If .false. do not stop molecular dynamics or ionic relaxation when electron_maxstep is reached. Use with care.
     */
    scf_must_converge?: boolean;
    conv_thr?: number;
    /**
     * If .TRUE. this turns on the use of an adaptive conv_thr for the inner scf loops when using EXX.
     */
    adaptive_thr?: boolean;
    /**
     * When adaptive_thr = .TRUE. this is the convergence threshold used for the first scf cycle.
     */
    conv_thr_init?: number;
    /**
     * When adaptive_thr = .TRUE. the convergence threshold for each scf cycle is given by: max( conv_thr, conv_thr_multi * dexx )
     */
    conv_thr_multi?: number;
    mixing_mode?: "plain" | "TF" | "local-TF";
    /**
     * mixing factor for self-consistency
     */
    mixing_beta?: number;
    /**
     * number of iterations used in mixing scheme
     */
    mixing_ndim?: number;
    /**
     * For DFT+U : number of iterations with fixed ns ( ns is the atomic density appearing in the Hubbard term ).
     */
    mixing_fixed_ns?: number;
    diagonalization?: "david" | "cg" | "ppcg" | "paro" | "ParO" | "rmm-davidson" | "rmm-paro";
    /**
     * Convergence threshold (ethr) for iterative diagonalization (the check is on eigenvalue convergence).
     */
    diago_thr_init?: number;
    /**
     * For conjugate gradient diagonalization:  max number of iterations
     */
    diago_cg_maxiter?: number;
    /**
     * For ppcg diagonalization:  max number of iterations
     */
    diago_ppcg_maxiter?: number;
    /**
     * For Davidson diagonalization: dimension of workspace (number of wavefunction packets, at least 2 needed).
     */
    diago_david_ndim?: number;
    /**
     * For RMM-DIIS diagonalization: dimension of workspace (number of wavefunction packets, at least 2 needed).
     */
    diago_rmm_ndim?: number;
    /**
     * If .TRUE., RMM-DIIS is performed up to converge. If .FALSE., RMM-DIIS is performed only once.
     */
    diago_rmm_conv?: boolean;
    /**
     * For RMM-DIIS diagonalization: blocking size of Gram-Schmidt orthogonalization
     */
    diago_gs_nblock?: number;
    /**
     * If .TRUE. all the empty states are diagonalized at the same level of accuracy of the occupied ones. Otherwise the empty states are diagonalized using a larger threshold (this should not affect total energy, forces, and other ground-state properties).
     */
    diago_full_acc?: boolean;
    /**
     * Amplitude of the finite electric field (in Ry a.u.; 1 a.u. = 36.3609*10^10 V/m). Used only if lelfield==.TRUE. and if k-points (K_POINTS card) are not automatic.
     */
    efield?: number;
    efield_cart?: ArrayOf3NumberElementsSchema;
    efield_phase?: "read" | "write" | "none";
    startingpot?: "atomic" | "file";
    startingwfc?: "atomic" | "atomic+random" | "random" | "file";
    /**
     * If .true., use a real-space algorithm for augmentation charges of ultrasoft pseudopotentials and PAWsets. Faster but numerically less accurate than the default G-space algorithm. Use with care and after testing!
     */
    tqr?: boolean;
    /**
     * If .true., exploit real-space localization to compute matrix elements for nonlocal projectors. Faster and in principle better scaling than the default G-space algorithm, but numerically less accurate, may lead to some loss of translational invariance. Use with care and after testing!
     */
    real_space?: boolean;
}
export interface IonsSchema1 {
    ion_positions?: "default" | "from_input";
    ion_velocities?: "default" | "from_input";
    /**
     * Used to extrapolate the potential from preceding ionic steps.
     */
    pot_extrapolation?: "none" | "atomic" | "first_order" | "second_order";
    /**
     * Used to extrapolate the wavefunctions from preceding ionic steps.
     */
    wfc_extrapolation?: "none" | "first_order" | "second_order";
    /**
     * This keyword is useful when simulating the dynamics and/or the thermodynamics of an isolated system. If set to true the total torque of the internal forces is set to zero by adding new forces that compensate the spurious interaction with the periodic images. This allows for the use of smaller supercells.
     */
    remove_rigid_rot?: boolean;
    ion_temperature?: "rescaling" | "rescale-v" | "rescale-T" | "reduce-T" | "berendsen" | "andersen" | "svr" | "initial" | "not_controlled";
    /**
     * Starting temperature (Kelvin) in MD runs target temperature for most thermostats.
     */
    tempw?: number;
    /**
     * Tolerance for velocity rescaling. Velocities are rescaled if the run-averaged and target temperature differ more than tolp.
     */
    tolp?: number;
    delta_t?: number;
    nraise?: number;
    /**
     * This keyword applies only in the case of molecular dynamics or damped dynamics. If true the ions are refolded at each step into the supercell.
     */
    refold_pos?: boolean;
    /**
     * Max reduction factor for conv_thr during structural optimization conv_thr is automatically reduced when the relaxation approaches convergence so that forces are still accurate, but conv_thr will not be reduced to less that conv_thr / upscale.
     */
    upscale?: number;
    /**
     * Number of old forces and displacements vectors used in the PULAY mixing of the residual vectors obtained on the basis of the inverse hessian matrix given by the BFGS algorithm.
     */
    bfgs_ndim?: number;
    /**
     * Maximum ionic displacement in the structural relaxation. (bfgs only)
     */
    trust_radius_max?: number;
    /**
     * Minimum ionic displacement in the structural relaxation BFGS is reset when trust_radius < trust_radius_min. (bfgs only)
     */
    trust_radius_min?: number;
    /**
     * Initial ionic displacement in the structural relaxation. (bfgs only)
     */
    trust_radius_ini?: number;
    w_1?: number;
    /**
     * Parameters used in line search based on the Wolfe conditions. (bfgs only)
     */
    w_2?: number;
    /**
     * Initial value of the alpha mixing factor in the FIRE minimization scheme; recommended values are between 0.1 and 0.3
     */
    fire_alpha_init?: number;
    /**
     * Scaling of the alpha mixing parameter for steps with P > 0;
     */
    fire_falpha?: number;
    /**
     * Minimum number of steps with P > 0 before increase of dt
     */
    fire_nmin?: number;
    /**
     * Factor for increasing dt
     */
    fire_f_inc?: number;
    /**
     * Factor for decreasing dt
     */
    fire_f_dec?: number;
    /**
     * Determines the maximum value of dt in the FIRE minimization; dtmax = fire_dtmax*dt
     */
    fire_dtmax?: number;
}
export interface CellSchema1 {
    /**
     * Target pressure [KBar] in a variable-cell md or relaxation run.
     */
    press?: number;
    /**
     * Fictitious cell mass [amu] for variable-cell simulations (both 'vc-md' and 'vc-relax'). Default: 0.75*Tot_Mass/pi**2 for Parrinello-Rahman MD; 0.75*Tot_Mass/pi**2/Omega**(2/3) for Wentzcovitch MD
     */
    wmass?: number;
    /**
     * Used in the construction of the pseudopotential tables. It should exceed the maximum linear contraction of the cell during a simulation. Default: 2.0 for variable-cell calculations, 1.0 otherwise
     */
    cell_factor?: number;
    /**
     * Convergence threshold on the pressure for variable cell relaxation ('vc-relax' : note that the other convergence thresholds for ionic relaxation apply as well).
     */
    press_conv_thr?: number;
    /**
     * Select which of the cell parameters should be moved
     */
    cell_dofree?: "all" | "ibrav" | "a" | "b" | "c" | "fixa" | "fixb" | "fixc" | "x" | "y" | "xy" | "xz" | "xyz" | "shape" | "volume" | "2Dxy" | "2Dshape" | "epitaxial_ab" | "epitaxial_ac" | "epitaxial_bc";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` ":pse:file:applications:espresso:::::pw:x:atomic-species".
 */
export interface AtomicSpeciesSchema {
    values?: {
        /**
         * label of the atom. Acceptable syntax: chemical symbol X (1 or 2 characters, case-insensitive) or chemical symbol plus a number or a letter, as in "Xn" (e.g. Fe1) or "X_*" or "X-*" (e.g. C1, C_h; max total length cannot exceed 3 characters)
         */
        X?: string;
        /**
         * mass of the atomic species [amu: mass of C = 12]. Used only when performing Molecular Dynamics run or structural optimization runs using Damped MD. Not actually used in all other cases (but stored in data files, so phonon calculations will use these values unless other values are provided)
         */
        Mass_X?: number;
        /**
         * PseudoPot_X
         */
        PseudoPot_X?: string;
    }[];
}
/**
 * https://www.quantum-espresso.org/Doc/INPUT_PW.html#idm1493
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` ":pse:file:applications:espresso:::::pw:x:atomic-positions".
 */
export interface AtomicPositionsSchema {
    card_option?: "alat" | "bohr" | "angstrom" | "crystal" | "crystal_sg";
    values?: {
        /**
         * label of the atom as specified in ATOMIC_SPECIES
         */
        X?: string;
        /**
         * atomic positions
         */
        x: number;
        /**
         * atomic positions
         */
        y: number;
        /**
         * atomic positions
         */
        z: number;
        "if_pos(1)"?: IntegerOneOrZero;
        "if_pos(2)"?: IntegerOneOrZero;
        "if_pos(3)"?: IntegerOneOrZero;
    }[];
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` ":pse:file:applications:espresso:::::pw:x:k-points".
 */
export interface KPointsSchema {
    card_option?: "tpiba" | "automatic" | "crystal" | "gamma" | "tpiba_b" | "crystal_b" | "tpiba_c" | "crystal_c";
    values?: {
        /**
         * Number of supplied special k-points.
         */
        nks?: number;
        xk_x?: number;
        xk_y?: number;
        xk_z?: number;
        wk?: number;
    }[] | {
        /**
         * Number of supplied special k-points.
         */
        nk1?: number;
        /**
         * Number of supplied special k-points.
         */
        nk2?: number;
        /**
         * Number of supplied special k-points.
         */
        nk3?: number;
        /**
         * Number of supplied special k-points.
         */
        sk1?: number;
        /**
         * Number of supplied special k-points.
         */
        sk2?: number;
        /**
         * Number of supplied special k-points.
         */
        sk3?: number;
    } | null;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` ":pse:file:applications:espresso:::::pw:x:cell-parameters".
 */
export interface CellParametersSchema {
    /**
     * label of the atom. Acceptable syntax: chemical symbol X (1 or 2 characters, case-insensitive) or chemical symbol plus a number or a letter, as in "Xn" (e.g. Fe1) or "X_*" or "X-*" (e.g. C1, C_h; max total length cannot exceed 3 characters)
     */
    card_option?: "alat" | "bohr" | "angstrom";
    values?: {
        v1?: ArrayOf3NumberElementsSchema;
        v2?: ArrayOf3NumberElementsSchema;
        v3?: ArrayOf3NumberElementsSchema;
    };
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` ":pse:file:applications:espresso:::::pw:x:hubbard".
 */
export interface HubbardSchema {
    card_option?: "atomic" | "ortho-atomic" | "norm-atomic" | "wf" | "pseudo";
    values?: ({
        /**
         * string constant "U"; indicates the specs for the U parameter will be given
         */
        U?: "U";
        /**
         * label of the atom (as defined in ATOMIC_SPECIES)
         */
        label?: string;
        /**
         * specs of the manifold (e.g., 3d, 2p...)
         */
        manifold?: string;
        /**
         * value of the U parameter (in eV)
         */
        u_val?: number;
    } | {
        /**
         * string constant "J0"; indicates the specs for the J0 parameter will be given
         */
        J0?: "J0";
        /**
         * label of the atom (as defined in ATOMIC_SPECIES)
         */
        label?: string;
        /**
         * specs of the manifold (e.g., 3d, 2p...)
         */
        manifold?: string;
        /**
         * value of the J0 parameter (in eV)
         */
        j0_val?: number;
    })[] | {
        /**
         * character describing the type of Hubbard parameter allowed values: U, J and either B (for d-orbitals) or E2 and E3 (for f-orbitals)
         */
        paramType?: "U" | "J" | "B" | "E2" | "E3";
        /**
         * label of the atom (as defined in ATOMIC_SPECIES)
         */
        label?: string;
        /**
         * specs of the manifold (e.g., 3d, 2p...)
         */
        manifold?: string;
        /**
         * value of the J0 parameter (in eV)
         */
        paramValue?: number;
    }[] | ({
        /**
         * string constant "U"; indicates the specs for the U parameter will be given
         */
        U?: "U";
        /**
         * label of the atom (as defined in ATOMIC_SPECIES)
         */
        label?: string;
        /**
         * specs of the manifold (e.g., 3d, 2p...)
         */
        manifold?: string;
        /**
         * value of the U parameter (in eV)
         */
        u_val?: number;
    } | {
        /**
         * string constant "J0"; indicates the specs for the J0 parameter will be given
         */
        J0?: "J0";
        /**
         * label of the atom (as defined in ATOMIC_SPECIES)
         */
        label?: string;
        /**
         * specs of the manifold (e.g., 3d, 2p...)
         */
        manifold?: string;
        /**
         * value of the J0 parameter (in eV)
         */
        j0_val?: number;
    } | {
        /**
         * string constant "V"; indicates the specs for the V parameter will be given
         */
        V?: "V";
        /**
         * label of the atom I (as defined in ATOMIC_SPECIES)
         */
        "label(I)"?: string;
        /**
         * specs of the manifold for atom I (e.g., 3d, 2p...)
         */
        "manifold(I)"?: string;
        /**
         * label of the atom J (as defined in ATOMIC_SPECIES)
         */
        "label(J)"?: string;
        /**
         * specs of the manifold for atom J (e.g., 3d, 2p...)
         */
        "manifold(J)"?: string;
        /**
         * index of the atom I
         */
        I?: number;
        /**
         * index of the atom J
         */
        J?: number;
        /**
         * value of the V parameter for the atom pair I,J (in eV)
         */
        "v_val(I,J)"?: number;
    })[];
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reference:modeling:exabyte".
 */
export interface InfoForCharacteristicObtainedByExabyteCalculation {
    type?: "exabyte";
    /**
     * Human-readable title of the job
     */
    title: string;
    /**
     * job identifier
     */
    _id: string;
    owner: EntityReferenceSchema;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reference:experiment".
 */
export interface InfoForCharacteristicObtainedByExperiment {
    type?: "experiment";
    /**
     * experiment authors
     */
    authors: ExperimentAuthorSchema[];
    /**
     * experiment title
     */
    title: string;
    /**
     * method used in experiment
     */
    method: string;
    conditions: ConditionSchema[];
    location?: LocationSchema;
    /**
     * epoch time.
     */
    timestamp: number;
    /**
     * Note about experiment
     */
    note?: string;
    /**
     * references to literature articles
     */
    references?: LiteratureReferenceSchema[];
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reference:literature:name".
 */
export interface ExperimentAuthorSchema {
    first: string;
    middle?: string;
    last: string;
    affiliation?: string;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reference:experiment:condition".
 */
export interface ConditionSchema {
    /**
     * condition unit
     */
    units?: string;
    /**
     * array of condition values
     */
    scalar?: {
        value?: string;
    }[];
    /**
     * human-readable name of the condition
     */
    name: string;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reference:experiment:location".
 */
export interface LocationSchema {
    /**
     * location latitude
     */
    latitude: number;
    /**
     * location longitude
     */
    longitude: number;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reference:literature".
 */
export interface LiteratureReferenceSchema {
    type?: "literature";
    /**
     * Digital Object Identifier of the reference.
     */
    doi?: string;
    /**
     * International Standard Book Number of the reference.
     */
    isbn?: string;
    /**
     * International Standard Serial Number of the reference.
     */
    issn?: string;
    /**
     * Internet address of the reference.
     */
    url?: string;
    /**
     * Title of the work.
     */
    title?: string;
    /**
     * Publisher of the work.
     */
    publisher?: string;
    /**
     * Journal in which the work appeared.
     */
    journal?: string;
    /**
     * Volume of the series in which the work appeared.
     */
    volume?: string;
    /**
     * Year in which the reference was published.
     */
    year?: string;
    /**
     * Issue of the collection in which the work appeared.
     */
    issue?: string;
    /**
     * Start and end pages of the work.
     */
    pages?: PagesSchema;
    /**
     * List of authors of the work.
     */
    authors?: ExperimentAuthorSchema[];
    /**
     * List of editors of the work.
     */
    editors?: ExperimentAuthorSchema[];
    /**
     * References cited by the work. Reference objects can nest as deeply as needed. This is useful, for example, when tracking the history of a value referenced in a scholarly article; the top level reference would contain information about where the data was accessed while the nested reference would contain information about where it was originally published.
     */
    reference?: {}[];
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reference:literature:pages".
 */
export interface PagesSchema {
    start: string;
    end?: string;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:abstract::d-data".
 */
export interface DimensionDataSchema {
    /**
     * array containing values of x Axis
     */
    xDataArray: unknown[];
    yDataSeries: DimensionDataSeriesSchema;
}
export interface DimensionPlotSchema2 {
    xAxis: AxisSchema;
    yAxis: AxisSchema;
    /**
     * Legend of y Axis data series
     *
     * @minItems 1
     */
    legend?: [unknown, ...unknown[]];
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:primitive:axis".
 */
export interface AxisSchema {
    /**
     * label of an axis object
     */
    label: string;
    /**
     * units for an axis
     */
    units?: string;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:abstract::d-grid".
 */
export interface DimensionalGridSchema {
    dimensions: ArrayOf3NumberElementsSchema;
    shifts: ArrayOf3NumberElementsSchema;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:primitive:group-info".
 */
export interface GroupInfoSchemaForNodesInAGraph {
    /**
     * Human-readable name of group of nodes
     */
    groupName?: string;
    /**
     * Unique identifier of the group a node belongs to
     */
    groupId?: string;
}
export interface BasicNodeSchemaLinkedList2 {
    /**
     * Flowchart ID of next node
     */
    next?: string;
    /**
     * Whether node is head node or not
     */
    head?: boolean;
}
export interface TypedNodeSchema2 {
    type?: string;
}
/**
 * container for machine- and human-readable identifier
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:primitive:slugified-entry".
 */
export interface SlugifiedEntry {
    /**
     * descriptive human-readable name of entry
     */
    name: string;
    /**
     * machine-readable identifier
     */
    slug: string;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reference:exabyte".
 */
export interface CoreReferenceExabyte {
    /**
     * Material's identity. Used for protoProperties.
     */
    materialId?: string;
    /**
     * Job's identity
     */
    jobId?: string;
    /**
     * Id of the unit that extracted the result
     */
    unitId?: string;
}
/**
 * Atomic properties per orbital e.g., Hubbard U parameters.
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reusable:atomic-data:per-orbital".
 */
export interface AtomicDataPerOrbital {
    /**
     * Site number or index in the lattice
     */
    id?: number;
    /**
     * Example: Co1, Mn
     */
    atomicSpecies?: string;
    orbitalName?: string;
}
/**
 * Numeric value specific to atomic data
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reusable:atomic-data:value-number".
 */
export interface AtomicDataNumericProperties {
    /**
     * Value related to a specific property, e.g., Hubbard U, V etc.
     */
    value?: number;
}
/**
 * Atomic properties per orbital pair e.g., Hubbard V parameters.
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reusable:atomic-data:per-orbital-pair".
 */
export interface AtomicDataPerOrbitalPair {
    /**
     * Site number or index in the lattice
     */
    id?: number;
    /**
     * Site number or index in the lattice of second site
     */
    id2?: number;
    /**
     * Example: Co1, Mn
     */
    atomicSpecies?: string;
    /**
     * Example: Co2, O
     */
    atomicSpecies2?: string;
    orbitalName?: string;
    orbitalName2?: string;
    /**
     * Distance between two sites in angstrom.
     */
    distance?: number;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reusable:atomic-orbital".
 */
export interface AtomicOrbitalSchema {
    orbitalName?: string;
    orbitalIndex?: number;
    principalNumber?: number;
    angularMomentum?: number;
    /**
     * Shell occupation
     */
    occupation?: number;
}
export interface BandGapSchema2 {
    kpointConduction?: PointSchema;
    kpointValence?: PointSchema;
    /**
     * eigenvalue at k-point in conduction band
     */
    eigenvalueConduction?: number;
    /**
     * eigenvalue at k-point in valence band
     */
    eigenvalueValence?: number;
    spin?: number;
    type: "direct" | "indirect";
    units?: "kJ/mol" | "eV" | "J/mol" | "hartree" | "cm-1" | "rydberg" | "eV/atom";
}
/**
 * Used to categorize entities such as models and methods
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reusable:categories".
 */
export interface Categories {
    tier1?: SlugifiedEntryOrSlug;
    tier2?: SlugifiedEntryOrSlug;
    tier3?: SlugifiedEntryOrSlug;
    type?: SlugifiedEntryOrSlug;
    subtype?: SlugifiedEntryOrSlug;
}
/**
 * Schema for a function of frequency yielding a nx3 matrix
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reusable:frequency-function-matrix".
 */
export interface CoreReusableFrequencyFunctionMatrix {
    /**
     * Frequencies
     */
    frequencies?: number[];
    /**
     * Matrix with 3 columns, e.g. x, y, z
     */
    components?: ArrayOf3NumberElementsSchema[];
}
export interface DielectricTensor2 {
    /**
     * Real or imaginary part of the dielectric tensor component
     */
    part: "real" | "imaginary";
    spin?: number;
}
export interface EnergySchema2 {
    name: string;
    units: ("kJ/mol" | "eV" | "J/mol" | "hartree" | "cm-1" | "rydberg" | "eV/atom") | "eV/A^2";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reusable:file-metadata".
 */
export interface FileMetadata {
    /**
     * Relative path to the directory that contains the file.
     */
    pathname?: string;
    /**
     * Basename of the file
     */
    basename?: string;
    /**
     * What kind of file this is, e.g. image / text
     */
    filetype?: string;
}
/**
 * String value specific to atomic data
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "core:reusable:atomic-data:string-value".
 */
export interface AtomicDataStringProperties {
    /**
     * String value specific to atomic data
     */
    value?: string;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "definitions:units".
 */
export interface DefinitionsUnits {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "material:conventional".
 */
export interface MaterialConventionalSchema {
    conventional?: {};
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:path".
 */
export interface PathSchema {
    path?: CategoryPathSchema;
}
export interface CategorizedMethod2 {
    units: CategorizedUnitMethod[];
}
export interface CategorizedUnitMethod2 {
    categories?: Categories;
    /**
     * Instructive parameters defining the method
     */
    parameters?: {};
    /**
     * Object showing the actual possible precision based on theory and implementation
     */
    precision?: {};
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:enum-options".
 */
export interface MethodsCategoryMathematicalEnumOptions {
    [k: string]: unknown;
}
export interface LinearMethodsCategorySchema2 {
    type?: "linear" | "kernel_ridge";
    subtype?: "least_squares" | "ridge";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:diff:enum-options".
 */
export interface MethodsCategoryMathematicalDiffEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:discr:enum-options".
 */
export interface MethodsCategoryMathematicalDiscrEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:discr:mesh:enum-options".
 */
export interface MethodsCategoryMathematicalDiscrMeshEnumOptions {
    [k: string]: unknown;
}
export interface CartesianGridSchema2 {
    type?: "cartesian";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:discr:mesh:struct:enum-options".
 */
export interface MethodsCategoryMathematicalDiscrMeshStructEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:fapprx:enum-options".
 */
export interface MethodsCategoryMathematicalFapprxEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:fapprx:ipol:enum-options".
 */
export interface MethodsCategoryMathematicalFapprxIpolEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:intgr:enum-options".
 */
export interface MethodsCategoryMathematicalIntgrEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:intgr:analytic:enum-options".
 */
export interface MethodsCategoryMathematicalIntgrAnalyticEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:intgr:diffeq:enum-options".
 */
export interface MethodsCategoryMathematicalIntgrDiffeqEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:intgr:numquad:enum-options".
 */
export interface MethodsCategoryMathematicalIntgrNumquadEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:intgr:transf:enum-options".
 */
export interface MethodsCategoryMathematicalIntgrTransfEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:linalg:enum-options".
 */
export interface MethodsCategoryMathematicalLinalgEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:linalg:diag:enum-options".
 */
export interface MethodsCategoryMathematicalLinalgDiagEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:opt:enum-options".
 */
export interface MethodsCategoryMathematicalOptEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:opt:diff:enum-options".
 */
export interface MethodsCategoryMathematicalOptDiffEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:opt:diff:ordern:enum-options".
 */
export interface MethodsCategoryMathematicalOptDiffOrdernEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:opt:ndiff:enum-options".
 */
export interface MethodsCategoryMathematicalOptNdiffEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:mathematical:opt:root:enum-options".
 */
export interface MethodsCategoryMathematicalOptRootEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:physical:enum-options".
 */
export interface MethodsCategoryPhysicalEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:physical:qm:enum-options".
 */
export interface MethodsCategoryPhysicalQmEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-category:physical:qm:wf:enum-options".
 */
export interface MethodsCategoryPhysicalQmWfEnumOptions {
    [k: string]: unknown;
}
export interface SmearingMethodsCategorySchema2 {
    type?: "smearing";
    subtype?: "gaussian" | "marzari-vanderbilt" | "methfessel-paxton" | "fermi-dirac";
}
export interface LegacyMethodLocalorbital2 {
    type?: "localorbital";
    subtype?: "pople";
}
export interface LegacyMethodPseudopotential2 {
    type?: "pseudopotential";
    subtype?: "paw" | "nc" | "us" | "any";
}
export interface LegacyMethodRegression2 {
    type?: "linear" | "kernel_ridge";
    subtype?: "least_squares" | "ridge";
    precision: RegressionPrecision;
    data: RegressionData;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:mathematical:regression:precision".
 */
export interface RegressionPrecision {
    perProperty?: RegressionPrecisionPerPropertySchema[];
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:mathematical:regression:precision-per-property".
 */
export interface RegressionPrecisionPerPropertySchema {
    /**
     * property name in 'flattened' format
     */
    name?: string;
    /**
     * training error of the estimator
     */
    trainingError: number;
    /**
     * prediction score of the estimator. Eg: r2_score
     */
    score?: number;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:mathematical:regression:data".
 */
export interface RegressionData {
    perProperty?: (LinearRegressionParametersSchema | KernelRidgeRegressionParametersSchema)[];
    dataSet?: MethodsDirectoryMathematicalRegressionDataset;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:mathematical:regression:linear:data-per-property".
 */
export interface LinearRegressionParametersSchema {
    /**
     * intercept (shift) from the linear or non-linear fit of data points
     */
    intercept: number;
    /**
     * per-feature (property used for training the ML method/model) parameters
     */
    perFeature: PerFeaturePropertyUsedForTrainingTheMLMethodModelParametersSchema[];
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:mathematical:regression:per-feature-item".
 */
export interface PerFeaturePropertyUsedForTrainingTheMLMethodModelParametersSchema {
    /**
     * coefficient in linear regression
     */
    coefficient?: number;
    /**
     * feature name
     */
    name: string;
    /**
     * pvalue: https://en.wikipedia.org/wiki/P-value
     */
    importance?: number;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:mathematical:regression:kernel-ridge:data-per-property".
 */
export interface KernelRidgeRegressionParametersSchema {
    /**
     * training data
     */
    xFit: unknown[];
    /**
     * dual coefficients
     */
    dualCoefficients: unknown[];
    /**
     * per-feature (property used for training the ML method/model) parameters
     */
    perFeature: PerFeaturePropertyUsedForTrainingTheMLMethodModelParametersSchema[];
}
/**
 * dataset for ml
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:mathematical:regression:dataset".
 */
export interface MethodsDirectoryMathematicalRegressionDataset {
    /**
     * array of exabyteIds for materials in dataset
     */
    exabyteIds: string[];
    /**
     * holder for any extra information, eg. coming from user-uploaded CSV file
     */
    extra?: {
        [k: string]: unknown;
    };
}
export interface LegacyMethodUnknown2 {
    type?: "unknown";
    subtype?: "unknown";
}
export interface UnitMethodConjugateGradient2 {
    categories: MethodsCategoryMathematicalOptDiffOrdernCg1;
}
export interface UnitMethodDavidson2 {
    categories: MethodsCategoryMathematicalLinalgDiagDavidson1;
}
export interface UnitMethodRegression2 {
    categories: LinearMethodsCategorySchema1;
    precision: RegressionPrecision;
    data: RegressionData;
}
export interface UnitMethodPseudopotential2 {
    categories: MethodsCategoryPhysicalQmWfPsp1;
    data?: PseudopotentialFile[];
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:physical:psp:file".
 */
export interface PseudopotentialFile {
    slug?: "pseudopotential";
    data?: FileDataItem;
    /**
     * TODO: remove in the future
     */
    source?: {
        info?: {};
        type?: string;
    };
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:physical:psp:file-data-item".
 */
export interface FileDataItem {
    /**
     * chemical element
     */
    element: string;
    /**
     * MD5 hash of the pseudopotential file
     */
    hash?: string;
    type: "us" | "nc" | "paw" | "coulomb";
    /**
     * explains where this came from
     */
    source: string;
    /**
     * explains the version of where this came from
     */
    version?: string;
    exchangeCorrelation: {
        /**
         * DFT approximation
         */
        approximation?: string;
        /**
         * Exchange correlation functional
         */
        functional?: string;
        path?: CategoryPathSchema;
    };
    /**
     * contains pseudo orbital information, including orbital names and occupations
     */
    valenceConfiguration?: AtomicOrbitalSchema[];
    /**
     * location of the pseudopotential file on filesystem
     */
    path: string;
    /**
     * The names of the simulation engines that can use this pseudopotential, e.g. espresso
     */
    apps: string[];
    /**
     * filename of pseudopotential file on filesystem
     */
    filename?: string;
    /**
     * name of the data category
     */
    name?: "pseudopotential";
}
export interface UnitMethodPlaneWave2 {
    categories: MethodsCategoryPhysicalQmWfPw1;
}
export interface UnitMethodSmearing2 {
    categories: SmearingMethodsCategorySchema1;
}
export interface UnitMethodTetrahedron2 {
    categories: MethodsCategoryPhysicalQmWfTetrahedron1;
}
export interface UnitMethodAoDunning2 {
    categories: MethodsCategoryPhysicalQmWfAoDunning1;
    parameters?: {
        basisSlug?: "cc-pvdz" | "cc-pvtz" | "cc-pvqz";
    };
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "methods-directory:physical:ao:enum-options".
 */
export interface MethodsDirectoryPhysicalAoEnumOptions {
    [k: string]: unknown;
}
export interface UnitMethodAoOther2 {
    categories: MethodsCategoryPhysicalQmWfAoOther1;
    parameters?: {
        basisSlug?: "sto-3g" | "sto-4g" | "sto-6g" | "def2-svp" | "def2-tzvp" | "def2-qzvp" | "cbs-qb3";
    };
}
export interface UnitMethodAoPople2 {
    categories: MethodsCategoryPhysicalQmWfAoPople1;
    parameters?: {
        basisSlug?: "3-21G" | "6-31G" | "6-311G";
    };
}
export interface ModelWithoutMethodSchemaBase2 {
    categories: Categories;
    /**
     * Model parameters defined in-place or via model mixins
     */
    parameters: {};
    reference?: LiteratureReferenceSchema;
}
export interface CategorizedModel2 {
    method: CategorizedMethod1;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "model:mixins:hubbard".
 */
export interface HubbardModelMixin {
    hubbardType?: "u";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "model:mixins:spin-polarization".
 */
export interface SpinPolarizationMixin {
    spinPolarization?: "collinear" | "non-collinear";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "model:mixins:spin-orbit-coupling".
 */
export interface SpinOrbitCouplingMixin {
    spinOrbitCoupling?: boolean;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "model:mixins:dispersion-correction".
 */
export interface DispersionCorrectionMixin {
    dispersionCorrection?: "dft-d2" | "dft-d3" | "xdm" | "ts";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "model:mixins:dft:lda-functional".
 */
export interface LDAFunctionalMixin {
    functional?: "pz";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "model:mixins:dft:gga-functional".
 */
export interface GGAFunctionalMixin {
    functional?: "pbe" | "pbesol";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "model:mixins:dft:mgga-functional".
 */
export interface MetaGGAFunctionalMixin {
    functional?: "scan";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "model:mixins:dft:hybrid-functional".
 */
export interface HybridFunctionalMixin {
    functional?: "hse06" | "b3lyp";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "model:mixins:dft:double-hybrid-functional".
 */
export interface DoubleHybridFunctionalMixin {
    functional?: "b2plyp";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "model:mixins:enum-options".
 */
export interface ModelMixinsEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "model:mixins:dft:enum-options".
 */
export interface ModelMixinsDftEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:enum-options".
 */
export interface ModelsCategoryEnumOptions {
    [k: string]: unknown;
}
export interface PhysicsBasedModelCategorySchema2 {
    tier1?: "pb";
}
export interface StatisticalModelCategorySchema2 {
    tier1?: "st";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:pb:enum-options".
 */
export interface ModelsCategoryPbEnumOptions {
    [k: string]: unknown;
}
export interface QuantumMechanicalCategorySchema2 {
    tier2?: "qm";
}
export interface AbInitioCategorySchema2 {
    tier3?: "abin";
}
export interface DensityFunctionalTheoryCategorySchema2 {
    tier3?: "dft";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:pb:qm:enum-options".
 */
export interface ModelsCategoryPbQmEnumOptions {
    [k: string]: unknown;
}
export interface SemiEmpiricalCategorySchema2 {
    tier3?: "semp";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:pb:qm:abin:enum-options".
 */
export interface ModelsCategoryPbQmAbinEnumOptions {
    [k: string]: unknown;
}
export interface GWCategorySchema2 {
    type?: "gw";
    subtype?: "g0w0" | "evgw0" | "evgw";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:pb:qm:dft:enum-options".
 */
export interface ModelsCategoryPbQmDftEnumOptions {
    [k: string]: unknown;
}
export interface KohnShamDFTCategorySchema2 {
    type?: "ksdft";
}
export interface DFTDoubleHybridFunctionalCategorySchema2 {
    subtype?: "double-hybrid";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:pb:qm:dft:ksdft:enum-options".
 */
export interface ModelsCategoryPbQmDftKsdftEnumOptions {
    [k: string]: unknown;
}
export interface DFTGGAFunctionalCategorySchema2 {
    subtype?: "gga";
}
export interface DFTHybridFunctionalCategorySchema2 {
    subtype?: "hybrid";
}
export interface DFTLDAFunctionalCategorySchema2 {
    subtype?: "lda";
}
export interface DFTMetaGGAFunctionalCategorySchema2 {
    subtype?: "mgga";
}
export interface DeterministicModelCategorySchema2 {
    tier2?: "det";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:st:enum-options".
 */
export interface ModelsCategoryStEnumOptions {
    [k: string]: unknown;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:st:det:enum-options".
 */
export interface ModelsCategoryStDetEnumOptions {
    [k: string]: unknown;
}
export interface MachineLearningModelCategorySchema2 {
    tier3?: "ml";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "models-category:st:det:ml:enum-options".
 */
export interface ModelsCategoryStDetMlEnumOptions {
    [k: string]: unknown;
}
export interface RegressionModelCategorySchema2 {
    type?: "re";
}
export interface ModelDoubleHybridFunctional2 {
    categories: DFTDoubleHybridFunctionalCategorySchema1;
    parameters: DoubleHybridFunctionalMixin & (SpinOrbitCouplingMixin | DispersionCorrectionMixin | SpinPolarizationMixin);
}
export interface ModelGeneralizedGradientApproximation2 {
    categories: DFTGGAFunctionalCategorySchema1;
    parameters: GGAFunctionalMixin & (SpinOrbitCouplingMixin | DispersionCorrectionMixin | SpinPolarizationMixin | HubbardModelMixin);
}
export interface ModelGwApproximation2 {
    categories: GWCategorySchema1;
    parameters: {
        require?: CategoryPathSchema;
    } & (LDAFunctionalMixin | GGAFunctionalMixin | MetaGGAFunctionalMixin) & (SpinPolarizationMixin | SpinOrbitCouplingMixin);
}
export interface ModelHybridFunctional2 {
    categories: DFTHybridFunctionalCategorySchema1;
    parameters: HybridFunctionalMixin & (SpinOrbitCouplingMixin | DispersionCorrectionMixin | SpinPolarizationMixin | HubbardModelMixin);
}
export interface ModelLocalDensityApproximation2 {
    categories: DFTLDAFunctionalCategorySchema1;
    parameters: LDAFunctionalMixin & (SpinOrbitCouplingMixin | DispersionCorrectionMixin | SpinPolarizationMixin | HubbardModelMixin);
}
export interface ModelMetaGeneralizedGradientApproximation2 {
    categories: DFTMetaGGAFunctionalCategorySchema1;
    parameters: MetaGGAFunctionalMixin & (SpinOrbitCouplingMixin | DispersionCorrectionMixin | SpinPolarizationMixin | HubbardModelMixin);
}
export interface ModelRegression2 {
    categories: RegressionModelCategorySchema1;
    parameters: {};
}
export interface LegacyModelDensityFunctionalTheory2 {
    type?: "dft";
}
export interface LegacyModelRegression2 {
    type?: "ml";
    subtype?: "re";
}
export interface LegacyModelUnknown2 {
    type?: "unknown";
    subtype?: "unknown";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:electronic-configuration".
 */
export interface ElectronicConfigurationSchema {
    /**
     * total charge of the molecular system
     */
    charge?: number;
    /**
     * calculated as 2S+1, with S is the total spin angular momentum
     */
    multiplicity?: number;
}
export interface AveragePotentialProfileSchema2 {
    xAxis?: {
        label?: "z coordinate";
        units?: "km" | "m" | "pm" | "nm" | "angstrom" | "a.u." | "bohr" | "fractional" | "crystal" | "cartesian" | "alat";
    };
    yAxis?: {
        label?: "energy";
        units?: "kJ/mol" | "eV" | "J/mol" | "hartree" | "cm-1" | "rydberg" | "eV/atom";
    };
    name?: "average_potential_profile";
}
/**
 * contains band gap values
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:non-scalar:band-gaps".
 */
export interface BandGapsSchema {
    name: "band_gaps";
    values?: BandGapSchema1[];
    eigenvalues?: {
        kpoint?: PointSchema;
        weight?: number;
        eigenvalues?: {
            spin?: number;
            energies?: unknown[];
            occupations?: unknown[];
        }[];
    }[];
}
export interface BandStructureSchema2 {
    xAxis?: {
        label?: "kpoints";
        units?: "km" | "m" | "pm" | "nm" | "angstrom" | "a.u." | "bohr" | "fractional" | "crystal" | "cartesian" | "alat";
    };
    yAxis?: {
        label?: "energy";
        units?: "kJ/mol" | "eV" | "J/mol" | "hartree" | "cm-1" | "rydberg" | "eV/atom";
    };
    name?: "band_structure";
    /**
     * spin of each band
     */
    spin?: (0.5 | -0.5)[];
}
export interface ChargeDensityProfileSchema2 {
    xAxis?: {
        label?: "z coordinate";
    };
    yAxis?: {
        label?: "charge density";
        units?: "e/A";
    };
    name?: "charge_density_profile";
}
export interface DensityOfStatesSchema2 {
    xAxis?: {
        label?: "energy";
        units?: "kJ/mol" | "eV" | "J/mol" | "hartree" | "cm-1" | "rydberg" | "eV/atom";
    };
    yAxis?: {
        label?: "density of states";
        units?: "states/unitcell";
    };
    name?: "density_of_states";
    legend?: {
        /**
         * chemical element
         */
        element?: string;
        /**
         * index inside sub-array of atoms of the same element type
         */
        index?: number;
        /**
         * electronic character and shell of PDOS, such as `1s` or `s`, or `total`
         */
        electronicState?: string;
        /**
         * spin of the electronic state
         */
        spin?: 0.5 | -0.5;
    }[];
}
/**
 * The real and imaginary parts of the diagonal elements of the dieletric tensor
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:non-scalar:dielectric-tensor".
 */
export interface DielectricTensorProperty {
    name: "dielectric_tensor";
    values?: DielectricTensor1[];
}
export interface FileContent2 {
    name: "file_content";
    /**
     * What kind of file this is, e.g. image / text
     */
    filetype?: "image" | "text" | "csv";
    objectData: ObjectStorageContainerData;
}
/**
 * Hubbard U value in eV
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:non-scalar:hubbard-u".
 */
export interface HubbardUParameters {
    name: "hubbard_u";
    units?: "eV";
    values?: AtomicDataPerOrbitalNumeric[];
}
/**
 * Hubbard V value in eV
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:non-scalar:hubbard-v".
 */
export interface HubbardVParameters {
    name: "hubbard_v";
    units?: "eV";
    values?: AtomicDataPerOrbitalPairNumeric[];
}
export interface PhononBandStructureSchema2 {
    xAxis?: {
        label?: "qpoints";
        units?: "km" | "m" | "pm" | "nm" | "angstrom" | "a.u." | "bohr" | "fractional" | "crystal" | "cartesian" | "alat";
    };
    yAxis?: {
        label?: "frequency";
        units?: "cm-1" | "THz" | "meV";
    };
    name?: "phonon_dispersions";
}
export interface PhononDensityOfStatesSchema2 {
    xAxis?: {
        label?: "frequency";
        units?: "cm-1" | "THz" | "meV";
    };
    yAxis?: {
        label?: "Phonon DOS";
        units?: "states/cm-1" | "states/THz" | "states/meV";
    };
    name?: "phonon_dos";
}
export interface PotentialProfileSchema2 {
    xAxis?: {
        label?: "z coordinate";
    };
    yAxis?: {
        label?: "energy";
        units?: "kJ/mol" | "eV" | "J/mol" | "hartree" | "cm-1" | "rydberg" | "eV/atom";
    };
    name?: "potential_profile";
}
export interface ReactionEnergyProfileSchema2 {
    xAxis?: {
        label?: "reaction coordinate";
    };
    yAxis?: {
        label?: "energy";
        units?: "kJ/mol" | "eV" | "J/mol" | "hartree" | "cm-1" | "rydberg" | "eV/atom";
    };
    name?: "reaction_energy_profile";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:non-scalar:stress-tensor".
 */
export interface StressTensorSchema {
    value?: DimensionalTensorSchema;
    name?: "stress_tensor";
    units?: "kbar" | "pa";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:non-scalar:total-energy-contributions".
 */
export interface TotalEnergyContributionsSchema {
    /**
     * product of temperature and configurational entropy
     */
    temperatureEntropy?: ScalarSchema;
    /**
     * non self-consitent energy based on an input charge density
     */
    harrisFoulkes?: ScalarSchema;
    /**
     * kinetic + pseudopotential energy
     */
    oneElectron?: ScalarSchema;
    /**
     * energy due to coulomb potential
     */
    hartree?: ScalarSchema;
    /**
     * exchange energy
     */
    exchange?: ScalarSchema;
    /**
     * exchange and correlation energy per particle
     */
    exchangeCorrelation?: ScalarSchema;
    /**
     * summation of interaction energies at long length scales due to coloumbic interactions
     */
    ewald?: ScalarSchema;
    /**
     * divergent electrostatic ion interaction in compensating electron gas
     */
    alphaZ?: ScalarSchema;
    /**
     * kinetic energy of wavefunctions in the atomic limit
     */
    atomicEnergy?: ScalarSchema;
    /**
     * sum of one electron energies of kinetic, electrostatic, and exchange correlation
     */
    eigenvalues?: ScalarSchema;
    /**
     * double counting correction 2
     */
    PAWDoubleCounting2?: ScalarSchema;
    /**
     * double counting correction 3
     */
    PAWDoubleCounting3?: ScalarSchema;
    /**
     * hartree-fock contribution
     */
    hartreeFock?: ScalarSchema;
    name?: "total_energy_contributions";
    units?: "kJ/mol" | "eV" | "J/mol" | "hartree" | "cm-1" | "rydberg" | "eV/atom";
}
export interface VibrationalSpectrumSchema2 {
    xAxis?: {
        label?: "frequency" | "wavenumber";
        units?: "cm-1" | "THz" | "meV";
    };
    yAxis?: {
        label?: "Intensity" | "Absorbance" | "Absorption coefficient";
        units?: "(debye/angstrom)^2" | "km/mol" | "m/mol" | "a.u.";
    };
    name?: "vibrational_spectrum";
}
export interface ElectronAffinitySchema2 {
    name?: "electron_affinity";
}
export interface FermiEnergySchema2 {
    name?: "fermi_energy";
}
export interface FormationEnergySchema2 {
    name?: "formation_energy";
}
export interface IonizationPotentialSchema2 {
    name?: "ionization_potential";
}
export interface Pressure2 {
    name?: "pressure";
    units?: "kbar" | "pa";
}
export interface ReactionEnergyBarrierSchema2 {
    name?: "reaction_energy_barrier";
}
export interface SurfaceEnergySchema2 {
    name?: "surface_energy";
}
export interface TotalEnergySchema2 {
    name?: "total_energy";
}
export interface TotalForcesSchema2 {
    name?: "total_force";
    units?: "eV/bohr" | "eV/angstrom" | "rydberg/a.u." | "newton" | "kg*m/s^2" | "eV/a.u.";
}
export interface ValenceBandOffsetSchema2 {
    name?: "valence_band_offset";
}
export interface ZeroPointEnergySchema2 {
    name?: "zero_point_energy";
}
/**
 * coordinates of atoms by ids, vector, unitless
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:atomic-forces".
 */
export interface AtomicForces {
    name?: "atomic_forces";
    values?: AtomicVectorsSchema3;
    units?: "eV/bohr" | "eV/angstrom" | "rydberg/a.u." | "newton" | "kg*m/s^2" | "eV/a.u.";
}
/**
 * magnetization on each ion
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:magnetic-moments".
 */
export interface MagneticMoments {
    name?: "magnetic_moments";
    values?: AtomicVectorsSchema4;
    units?: "uB";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:patterns:functional-group".
 */
export interface FunctionalGroupPatternSchema {
    name?: "functional_group";
    atoms?: AtomicIds & {
        /**
         * whether atom connects to atoms outside of functional group.
         */
        isConnector?: boolean;
    }[];
    /**
     * SMARTS string for classification of FG; https://en.wikipedia.org/wiki/SMILES_arbitrary_target_specification
     */
    SMARTS?: string;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:patterns:ring".
 */
export interface RingPatternSchema {
    name?: "ring";
    atoms?: AtomicIds & {
        /**
         * whether atom connects to atoms outside of functional group.
         */
        isConnector?: boolean;
    }[];
    isAromatic?: boolean;
}
/**
 * Any bonding interaction that cannot be described by simple 2-atom picture, e.g. 3-center-2-electron bond in diborane
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:patterns:special-bond".
 */
export interface SpecialBondPatternSchema {
    name?: "special_bond";
    atoms?: AtomicIds & {
        /**
         * whether atom connects to atoms outside of functional group.
         */
        isConnector?: boolean;
    }[];
}
/**
 * atomic constraints schema
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:basis:atomic-constraints".
 */
export interface AtomicConstraints {
    name?: "atomic_constraints";
    values?: AtomicVectorsSchema5;
}
/**
 * coordinates of atoms by ids, vector, unitless
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:structural:basis:atomic-coordinates".
 */
export interface AtomicCoordinates {
    name?: "atomic_coordinates";
    values?: AtomicCoordinate[];
    units?: "km" | "m" | "pm" | "nm" | "angstrom" | "a.u." | "bohr" | "fractional" | "crystal" | "cartesian" | "alat";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:workflow:convergence:electronic".
 */
export interface ElectronicSelfConsistencyConvergenceSchema {
    name?: "convergence_electronic";
    units?: "eV" | "rydberg" | "hartree";
    data: number[][];
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:workflow:convergence:ionic".
 */
export interface IonicConvergenceSchema {
    name?: "convergence_ionic";
    /**
     * for ionic convergence tolerance shows force tolerance
     */
    tolerance?: {
        [k: string]: unknown;
    };
    /**
     * units for force tolerance
     */
    units?: "eV";
    /**
     * energetic and structural information
     */
    data: {
        /**
         * converged electronic energy for this structure (last in `electronic`)
         */
        energy?: number;
        /**
         * TODO: structural information at each step to be here
         */
        structure?: {};
        /**
         * data about electronic at this ionic step
         */
        electronic?: {
            /**
             * units for force tolerance
             */
            units?: "eV" | "rydberg" | "hartree";
            data?: number[];
        };
    }[];
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "properties-directory:workflow:convergence:kpoint".
 */
export interface ConvergenceSchemaForConvergingAPropertyWrtKpoints {
    /**
     * tolerance for the property under investigation
     */
    tolerance: {
        [k: string]: unknown;
    };
    /**
     * units for the property under investigation
     */
    units: string;
    /**
     * name of the property under investigation
     */
    property?: string;
    /**
     * kpoint grid and property information
     */
    data: {
        /**
         * value of the property at this step
         */
        value: {
            [k: string]: unknown;
        };
        /**
         * information about the kpoint grid
         */
        grid: {};
        /**
         * optional kpoint spacing information
         */
        spacing?: number;
    }[];
}
export interface SchemaOfBaseMaterialSPreliminaryProperty2 {
    /**
     * property slug, e.g. total_energy
     */
    slug?: string;
    /**
     * property group, e.g. qe:dft:gga:pbe
     */
    group?: string;
    /**
     * container of the information, specific to each property
     */
    data: {};
    source: TheSourceOfAPropertyThisCouldBeAnArticleASimulationOnExabyteAnExternalSimulationEtc;
    /**
     * Id of the corresponding item in the entity bank that this property is obtained for
     */
    exabyteId?: string[];
    precision?: {};
    /**
     * total number of properties among which this property is the best.
     */
    count?: number;
    /**
     * property system tags, marks property system characteristics, values refined or best (could be both)
     */
    systemTags?: ("isRefined" | "isBest")[];
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "property:source".
 */
export interface TheSourceOfAPropertyThisCouldBeAnArticleASimulationOnExabyteAnExternalSimulationEtc {
    /**
     * Type of the material property's source.
     */
    type?: string;
    /**
     * Internet address of the reference.
     */
    url?: string;
    info?: CoreReferenceExabyte | InfoForCharacteristicObtainedByExperiment;
}
export interface SchemaOfMaterialSPreliminaryProperty2 {
    /**
     * property slug, e.g. total_energy
     */
    slug?: string;
    /**
     * property group, e.g. qe:dft:gga:pbe
     */
    group?: string;
    /**
     * container of the information, specific to each property
     */
    data: {};
    source: TheSourceOfAPropertyThisCouldBeAnArticleASimulationOnExabyteAnExternalSimulationEtc;
    /**
     * Id of the corresponding item in the entity bank that this property is obtained for
     */
    exabyteId?: string[];
    precision?: {};
    /**
     * total number of properties among which this property is the best.
     */
    count?: number;
    /**
     * property system tags, marks property system characteristics, values refined or best (could be both)
     */
    systemTags?: ("isRefined" | "isBest")[];
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit:input:-inputItem".
 */
export interface ExecutionUnitInputItemSchemaForPhysicsBasedSimulationEngines {
    /**
     * Input file name. e.g. pw_scf.in
     */
    name: string;
    /**
     * Content of the input file. e.g. &CONTROL    calculation='scf' ...
     */
    content: string;
}
export interface TemplateSchema2 {
    applicationName?: string;
    applicationVersion?: string;
    executableName?: string;
    contextProviders?: NameResultSchema[];
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:ml:exabyteml".
 */
export interface ExabyteMachineLearningEngineSchema {
    name?: "exabyteml";
    summary?: "exabyte machine learning engine";
    version?: "0.2.0";
}
export interface CrossValidationUnitSchema2 {
    /**
     * TODO: consider keeping executable `evaluate` and flavor `cross-validate` as before
     */
    input?: {
        /**
         * number of groups to split the training dataset for cross-validation
         */
        nSplits: number;
    };
}
export interface TrainUnitSchema2 {
    /**
     * model train unit (NOTE: info about method, eg. regression/linear is taken from (sub)workflow)
     */
    input?: {
        /**
         * material features used for model fitting
         */
        features: string[];
        /**
         * target properties to train for
         */
        targets: string[];
    };
}
export interface TrainScoreSchema2 {
    input?: unknown;
}
export interface InitializeUnitSchema2 {
    /**
     * model init unit (NOTE: info about method, eg. regression/linear is taken from (sub)workflow)
     */
    input?: {
        /**
         * target properties to predict (NOTE: must be a subset of targets for which training was done)
         */
        targets: string[];
    };
}
export interface ScaleAndReduceUnitSchema2 {
    operation?: "data_transformation";
    operationType?: "scale_and_reduce";
    inputData?: {
        /**
         * type of scaler to be applied
         */
        scaler: "standard_scaler";
        perFeature?: {
            /**
             * variance in original training data
             */
            variance?: number;
            /**
             * mean value of the original training data
             */
            mean?: number;
            /**
             * scale multiplier for this feature/property
             */
            scale: number;
            /**
             * feature/property name in 'flattened' format
             */
            name: string;
        }[];
    };
}
export interface FilterBasedFeatureSelectionUnitSchema2 {
    operation?: "feature_selection";
    operationType?: "filter_based";
    inputData?: {
        /**
         * number of features to select for model training. If equal to 0, will use all available features
         */
        nFeatures: number;
        /**
         * feature selection algorithm following sklearn.feature_selection
         */
        algorithm: "f_regression";
    };
}
export interface ManipulationUnitSchema2 {
    operation?: "data_transformation";
    operationType?: "manipulation";
    inputData?: {
        /**
         * whether to clean missing data, eg. NaN
         */
        cleanMissingData: boolean;
        /**
         * whether to remove duplicate rows
         */
        removeDuplicateRows: boolean;
        /**
         * replace None values with a given value
         */
        replaceNoneValuesWith: number;
    };
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "software-directory:modeling:espresso".
 */
export interface EspressoAppSchema {
    name?: "espresso";
    summary?: "Quantum Espresso";
    version?: "5.1.1" | "5.2.1" | "5.4.0" | "6.0.0";
}
export interface NWChem2 {
    name?: "NWChem";
    summary?: "NWChem: a comprehensive and scalable open-source solution for large scale molecular simulations";
    version?: "6.6" | "7.0.2";
    exec?: "nwchem";
}
export interface ViennaAbInitoSimulationPackage2 {
    name?: "vasp";
    summary?: "vienna ab-initio simulation package";
    flavor?: "vasp" | "vasp_nscf" | "vasp_bands";
    version?: "5.3.5";
    exec?: "vasp";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit:input:-input".
 */
export interface ExecutionUnitInputSchemaForPhysicsBasedSimulationEngines {
    input?: ExecutionUnitInputSchema1;
}
export interface JupyterLabApplicationSchema2 {
    name?: "jupyterLab";
    flavor?: "notebook";
    summary?: "Jupyter Lab";
    version?: "0.33.12";
    exec?: "jupyter";
}
export interface PythonProgramingLanguageSchema2 {
    name?: "python";
    flavor?: "python2" | "python3";
    summary?: "Python Script";
    version?: "2.7.5" | "3.6.1";
    exec?: "python";
    /**
     * Optional arguments passed to the Python script
     */
    arguments?: string;
    /**
     * Optional environment variables exported before running the Python script
     */
    environment?: {};
    /**
     * Optional Python dependencies, e.g. amqp==1.4.6
     */
    dependencies?: unknown[];
}
export interface ShellScriptingLanguageSchema2 {
    name?: "shell";
    flavor?: "sh" | "bash" | "zsh" | "csh";
    summary?: "Shell Script";
    version?: "4.2.46";
    exec?: "sh" | "bash" | "zsh" | "csh";
    /**
     * Optional arguments passed to the Shell script
     */
    arguments?: string;
    /**
     * Optional environment variables exported before running the Shell script
     */
    environment?: {};
}
export interface MaterialEntityReferenceSchema2 {
    /**
     * Material class
     */
    cls?: "Material";
}
export interface ParentJobEntityReferenceSchema2 {
    /**
     * Job class
     */
    cls?: "Job";
}
export interface ProjectEntityReferenceSchema2 {
    /**
     * Project class
     */
    cls?: "Project";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:bankable".
 */
export interface BankableSchema {
    /**
     * Identity of the corresponding bank entity
     */
    exabyteId?: string;
    /**
     * Hash string which is calculated based on the meaningful fields of the entity. Used to identify equal entities.
     */
    hash?: string;
}
export interface CreatorEntityReferenceSchema2 {
    /**
     * Creator class
     */
    cls?: "User";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:creator-account".
 */
export interface CreatorAccountSchema {
    creatorAccount?: EntityReferenceSchema;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:description".
 */
export interface ExtendedBaseEntitySchema {
    /**
     * entity description
     */
    description?: string;
    descriptionObject?: {};
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:history".
 */
export interface HistorySchema {
    history?: {
        id: string;
        revision: number;
    }[];
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:in-set".
 */
export interface SystemInSetSchema {
    inSet?: (EntityReferenceSchema & {
        type?: string;
        index?: number;
    })[];
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:is-multi-material".
 */
export interface IsMultiSchema {
    isMultiMaterial?: boolean;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:is-outdated".
 */
export interface IsOutdatedSchema {
    isOutdated?: boolean;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:job-extended".
 */
export interface ExtendedJobSchema {
    mode?: string;
    isExternal?: boolean;
    _materials?: EntityReferenceSchema[];
    _materialsSet?: EntityReferenceSchema;
    purged?: boolean;
    purgedAt?: number;
    dataset?: {};
}
/**
 * communication message between Rupy and web application.
 *
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:message".
 */
export interface MessageSchema {
    header: {
        entity: {
            /**
             * job identifier
             */
            _id: string;
            /**
             * entity name.
             */
            name: "job" | "unit";
            /**
             * unit identifier within the workflow
             */
            flowchartId?: string;
            /**
             * source of the message.
             */
            probe?: "monitor" | "postprocessor";
        };
        /**
         * Rupy-Webapp communication schema version.
         */
        version: string;
        /**
         * Timestamp of the message.
         */
        timestamp: number;
    };
    /**
     * Actual payload of the message.
     */
    payload: {};
}
export interface EntityOwnerReferenceSchema2 {
    /**
     * Entity owner class
     */
    cls?: "Account";
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:scope".
 */
export interface ScopeSchema {
    scope?: string;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:set".
 */
export interface EntitySetSchema {
    isEntitySet?: boolean;
    entitySetType?: string;
    entityCls?: string;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:sharing".
 */
export interface ExtendedSharingSchema {
    sharedCount?: number;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:soft-removable".
 */
export interface SoftRemovableEntitySchema {
    /**
     * Timestamp of the moment when entity was removed
     */
    removedAt?: string;
    /**
     * Identifies that entity was removed
     */
    removed?: boolean;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:status".
 */
export interface StatusSchema {
    status?: string;
    statusTrack?: {
        trackedAt: number;
        status: string;
        repetition?: number;
    }[];
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:timestampable".
 */
export interface TimestampableEntitySchema {
    /**
     * entity creation time
     */
    createdAt?: string;
    /**
     * entity last modification time
     */
    updatedAt?: string;
    createdBy?: string | number;
    updatedBy?: string | number;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "system:use-values".
 */
export interface UseValuesSchema {
    useValues?: boolean;
}
/**
 * This interface was referenced by `GlobalSchema`'s JSON-Schema
 * via the `definition` "workflow:unit:runtime:-runtime-item-full-object".
 */
export interface FullResultSchema {
    /**
     * The name of this item. e.g. 'my_custom_property. <OTHER FIELDS TO BE ADDED>'
     */
    name: string;
}
